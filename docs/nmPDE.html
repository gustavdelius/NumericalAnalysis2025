<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>9&nbsp; Partial Differential Equations – Numerical Analysis 2025</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./nmODE.html" rel="prev">
<link href="./faviconNA.webp" rel="icon">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-eee2ee4d5e4f76f365a16d0cec9c0489.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="9&nbsp; Partial Differential Equations – Numerical Analysis 2025">
<meta property="og:description" content="">
<meta property="og:image" content="figures/PDE/HeatStencil.png">
<meta property="og:site_name" content="Numerical Analysis 2025">
<meta name="twitter:title" content="9&nbsp; Partial Differential Equations – Numerical Analysis 2025">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="figures/PDE/HeatStencil.png">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./nmPDE.html"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Partial Differential Equations</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Numerical Analysis 2025</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://vle.york.ac.uk/ultra/courses/_111634_1/outline" title="VLE" class="quarto-navigation-tool px-1" aria-label="VLE"><i class="bi bi-house-door-fill"></i></a>
    <a href="https://maths.york.ac.uk/moodle/course/view.php?id=2725" title="Moodle quizzes" class="quarto-navigation-tool px-1" aria-label="Moodle quizzes"><i class="bi bi-mortarboard-fill"></i></a>
    <a href="https://forms.gle/Z8nYvVonGN98L7nv5" title="Submit a correction" class="quarto-navigation-tool px-1" aria-label="Submit a correction"><i class="bi bi-bug-fill"></i></a>
    <a href="./Numerical-Analysis-2025.pdf" title="PDF" class="quarto-navigation-tool px-1" aria-label="PDF"><i class="bi bi-file-pdf"></i></a>
    <a href="https://github.com/gustavdelius/NumericalAnalysis2025/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmPython.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Essential Python</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmNumbers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Numbers</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmFunctions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Functions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmNonlinear.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Non-linear Equations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmDerivatives.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Derivatives</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmIntegrals.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Integrals</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmOptima.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Optima</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmODE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Ordinary Differential Equations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmPDE.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Partial Differential Equations</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#intro-to-pdes" id="toc-intro-to-pdes" class="nav-link active" data-scroll-target="#intro-to-pdes"><span class="header-section-number">9.1</span> Intro to PDEs</a></li>
  <li><a href="#the-heat-equation" id="toc-the-heat-equation" class="nav-link" data-scroll-target="#the-heat-equation"><span class="header-section-number">9.2</span> The Heat Equation</a>
  <ul>
  <li><a href="#sec-heat1d" id="toc-sec-heat1d" class="nav-link" data-scroll-target="#sec-heat1d"><span class="header-section-number">9.2.1</span> In One Spatial Dimensions</a></li>
  <li><a href="#sec-neumann" id="toc-sec-neumann" class="nav-link" data-scroll-target="#sec-neumann"><span class="header-section-number">9.2.2</span> Different Boundary Conditions</a></li>
  <li><a href="#sec-heat2d" id="toc-sec-heat2d" class="nav-link" data-scroll-target="#sec-heat2d"><span class="header-section-number">9.2.3</span> In Two Spatial Dimensions</a></li>
  <li><a href="#sec-heatvar" id="toc-sec-heatvar" class="nav-link" data-scroll-target="#sec-heatvar"><span class="header-section-number">9.2.4</span> Variations on the Heat Equation</a>
  <ul class="collapse">
  <li><a href="#sec-rde" id="toc-sec-rde" class="nav-link" data-scroll-target="#sec-rde"><span class="header-section-number">9.2.4.1</span> Reaction-Diffusion Equations</a></li>
  <li><a href="#sec-advect" id="toc-sec-advect" class="nav-link" data-scroll-target="#sec-advect"><span class="header-section-number">9.2.4.2</span> Advective-Diffusion Equations</a></li>
  </ul></li>
  <li><a href="#sec-heat_stability" id="toc-sec-heat_stability" class="nav-link" data-scroll-target="#sec-heat_stability"><span class="header-section-number">9.2.5</span> Implicit Methods</a></li>
  <li><a href="#sec-stability-heat" id="toc-sec-stability-heat" class="nav-link" data-scroll-target="#sec-stability-heat"><span class="header-section-number">9.2.6</span> Stability</a></li>
  </ul></li>
  <li><a href="#the-wave-equation" id="toc-the-wave-equation" class="nav-link" data-scroll-target="#the-wave-equation"><span class="header-section-number">9.3</span> The Wave Equation</a></li>
  <li><a href="#the-travelling-wave-equation" id="toc-the-travelling-wave-equation" class="nav-link" data-scroll-target="#the-travelling-wave-equation"><span class="header-section-number">9.4</span> The Travelling Wave Equation</a></li>
  <li><a href="#the-laplace-and-poisson-equations" id="toc-the-laplace-and-poisson-equations" class="nav-link" data-scroll-target="#the-laplace-and-poisson-equations"><span class="header-section-number">9.5</span> The Laplace and Poisson Equations</a></li>
  <li><a href="#algorithm-summaries" id="toc-algorithm-summaries" class="nav-link" data-scroll-target="#algorithm-summaries"><span class="header-section-number">9.6</span> Algorithm Summaries</a></li>
  <li><a href="#problems" id="toc-problems" class="nav-link" data-scroll-target="#problems"><span class="header-section-number">9.7</span> Problems</a></li>
  <li><a href="#projects" id="toc-projects" class="nav-link" data-scroll-target="#projects"><span class="header-section-number">9.8</span> Projects</a>
  <ul>
  <li><a href="#hunting-and-diffusion" id="toc-hunting-and-diffusion" class="nav-link" data-scroll-target="#hunting-and-diffusion"><span class="header-section-number">9.8.1</span> Hunting and Diffusion</a></li>
  <li><a href="#heating-adobe-houses" id="toc-heating-adobe-houses" class="nav-link" data-scroll-target="#heating-adobe-houses"><span class="header-section-number">9.8.2</span> Heating Adobe Houses</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/gustavdelius/NumericalAnalysis2025/edit/main/nmPDE.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-pde" class="quarto-section-identifier"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Partial Differential Equations</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<blockquote class="blockquote">
<p><em>When you open the toolkit of differential equations you see the hammers and saws of engineering and physics for the past two centuries and for the foreseeable future.</em><br>
–<a href="https://en.wikipedia.org/wiki/Benoit_Mandelbrot">Benoit Mandelbrot</a></p>
</blockquote>
<section id="intro-to-pdes" class="level2" data-number="9.1">
<h2 data-number="9.1" class="anchored" data-anchor-id="intro-to-pdes"><span class="header-section-number">9.1</span> Intro to PDEs</h2>
<p>Partial differential equations (PDEs) are differential equations involving the partial derivatives of an unknown multivariable function. In most of this chapter we will examine two classical problems from physics: heat transport phenomena and wave phenomena. Do not think, however, that just because we are focusing on these two primary examples that this is the extent of the utility of PDEs. Basically, every scientific field has been impacted by (or has directly impacted) the study of PDEs. Any phenomenon that can be modelled via the change in multiple continuous variables (not restricted to space and time) is likely governed by a PDE model. Some common phenomena that are modelled by PDEs are:</p>
<ul>
<li><p>heat transport</p>
<ul>
<li>The heat equation models heat energy (temperature) diffusing through a metal rod or a solid body</li>
</ul></li>
<li><p>diffusion of a concentrated substance</p>
<ul>
<li>The diffusion equation is a PDE model for the diffusion of smells, contaminants, or the motion of a solute</li>
</ul></li>
<li><p>wave propagation</p>
<ul>
<li>The wave equation is a PDE that can be used to model the standing waves on a guitar string, the waves on lake, or sound waves traveling through the air</li>
</ul></li>
<li><p>travelling waves</p>
<ul>
<li>The traveling wave equation is a PDE that can be used to model pulses of light propagating through a fiber optic cable or regions of high density traffic moving along a highway.</li>
</ul></li>
<li><p>quantum mechanics</p>
<ul>
<li>The wave functions of quantum mechanics are described by a PDE called the Schrodinger Equation.</li>
</ul></li>
<li><p>electro-magnetism</p>
<ul>
<li>Maxwell’s Equations are a system of PDEs describing the relationships between electricity and magnetism.</li>
</ul></li>
<li><p>fluid flow</p>
<ul>
<li><p>The Navier-Stokes equations are a system of PDEs that model fluids in three dimensions – including turbulent flow.</p></li>
<li><p>Darcy’s Law and Richard’s equation are PDE models for the motion of fluids moving through saturated and unsaturated soils.</p></li>
</ul></li>
<li><p>stress and strain in structures</p>
<ul>
<li>The Linear Elasticity equation is a PDE that models the stresses in a solid body (like a bridge or a building) under load.</li>
</ul></li>
<li><p>spatial patterns</p>
<ul>
<li>Solutions to the Helmholtz equation are known for exhibiting <em>Turing patterns</em> which are patterns like leopard spots or zebra stripes.</li>
</ul></li>
<li><p>… and many more …</p></li>
</ul>
<p>In many cases we are interested in solving PDEs in terms of our usual three spatial dimensions along with an extra dimension for time. Often we do not have to work with all three spatial dimensions (like if the domain is much larger in one or two directions versus the others) or in some cases (like in linear elasticity) we do not need to worry about time.</p>
<p>There is a wealth of wonderful theory for finding analytic solutions to many special classes of PDEs. However, most PDEs simply do not lend themselves to analytic solutions that we can write down in terms of the regular mathematical operations of sums, products, powers, roots, trigonometric functions, logarithms, etc. For these PDEs we must turn to numerical methods to approximate the solution.</p>
<p>Recall that numerical solutions to ODEs were approximations of the value of the unknown function at a discrete set of times. Similarly, numerical solutions to PDEs are going to be approximations of the value of the unknown function at a discrete set of points in time AND space.</p>
<p>What we will cover in this chapter will include one primary and powerful technique for approximating solutions to PDEs: <strong>the finite difference method</strong>. There are many other techniques for approximating solutions to PDEs, and the field of numerical PDEs is still an active area of mathematical and scientific research.</p>
</section>
<section id="the-heat-equation" class="level2" data-number="9.2">
<h2 data-number="9.2" class="anchored" data-anchor-id="the-heat-equation"><span class="header-section-number">9.2</span> The Heat Equation</h2>
<p>You have probably met the heat equation, also known as the diffusion equation, in a previous module. The heat equation is a partial differential equation that describes how heat diffuses through a material. The heat equation is a parabolic PDE and is given by <span class="math display">\[
\frac{\partial u}{\partial t} = D \nabla^2 u
\]</span> where <span class="math inline">\(u(t,x)\)</span> is the temperature of the material at time <span class="math inline">\(t\)</span> and position <span class="math inline">\(x\)</span> and <span class="math inline">\(D\)</span> is the diffusion coefficient. The heat equation is a simple model for heat diffusion but also describes diffusion in general, like the diffusion of a solute in a solvent or of plants in a field or, …. well, you get the idea.</p>
<p>In the remainder of this section we will use a technique called <strong>the finite difference method</strong> to build numerical approximations to solutions of the heat equation in 1D, 2D, and 3D. You of course know that the heat equation is easy to solve analytically, given that it is a linear homogeneous PDE with constant coefficients. However, the finite difference method is a powerful tool for solving similar PDEs that do not have simple analytic solutions. The advantage of using the heat equation as a test case for the finite difference method is that we can easily verify the accuracy of our numerical solutions by comparing them to the known analytic solutions.</p>
<section id="sec-heat1d" class="level3" data-number="9.2.1">
<h3 data-number="9.2.1" class="anchored" data-anchor-id="sec-heat1d"><span class="header-section-number">9.2.1</span> In One Spatial Dimensions</h3>
<p>For the sake of simplicity we will start by considering the heat equation in 1 spatial dimension: <span class="math display">\[
\frac{\partial u}{\partial t} = D \frac{\partial^2 u}{\partial x^2}.
\]</span> We will also use the alternative notation <span id="eq-heat1d"><span class="math display">\[
u_t = D u_{xx},
\tag{9.1}\]</span></span> where the subscripts denote partial derivatives.</p>
<div id="exr-6.29" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.1</strong></span> Just as we did in <a href="nmODE.html" class="quarto-xref">Chapter&nbsp;<span>8</span></a> to approximate solutions to ODEs, we will start by partitioning the spatial domain into finitely many pieces and we will partition time into finitely many pieces. We do this by introducing a grid of points <span class="math inline">\((t_n,x_i)\)</span> where <span class="math inline">\(t_n = t_0 + n\,\Delta t\)</span> and <span class="math inline">\(x_i = x_0 + i\,\Delta x\)</span>. Then we want to build a numerical approximation to the function <span class="math inline">\(u(t,x)\)</span> at these grid points.</p>
<p>First we need to introduce some notation for the numerical solution. As you will see in a moment, there is a lot to keep track of in numerical PDEs so careful indexing and well-chosen notation is essential. Let <span class="math inline">\(U_i^n\)</span> be the approximation of the solution to <span class="math inline">\(u(t,x)\)</span> at the point <span class="math inline">\(t=t_n=t_0+n\,\Delta t\)</span> and <span class="math inline">\(x=x_i=x_0+i\,\Delta x\)</span> (since we have two variables we need two indices). For example, <span class="math inline">\(U_4^1\)</span> is the value of the approximation at time <span class="math inline">\(t_1\)</span> and at the spatial point <span class="math inline">\(x_4\)</span>.</p>
<p>Next we need to approximate both derivatives <span class="math inline">\(u_t\)</span> and <span class="math inline">\(u_{xx}\)</span> in the PDE using methods that we have used before. Now would be a good time to go back to <a href="nmDerivatives.html" class="quarto-xref">Chapter&nbsp;<span>5</span></a> and refresh your memory for how we build approximations of derivatives.</p>
<ol type="a">
<li><p>Use the forward-difference formula to approximate the time derivative <span class="math inline">\(u_t\)</span> at the point <span class="math inline">\(t=t_n\)</span> and <span class="math inline">\(x=x_i\)</span>. <span class="math display">\[
u_t(t_n,x_i) \approx \frac{??? - ???}{???}.
\]</span></p></li>
<li><p>Use the centred-difference formula to approximate the second spatial derivative <span class="math inline">\(u_{xx}\)</span> at the point <span class="math inline">\(t=t_n\)</span> and <span class="math inline">\(x=x_i\)</span>. <span class="math display">\[
u_{xx}(t_n,x_i) \approx \frac{??? - ??? + ???}{???}.
\]</span></p></li>
<li><p>Put your answers from parts (a) and (b) together using the 1D heat equation (<a href="#eq-heat1d" class="quarto-xref">Eq.&nbsp;<span>9.1</span></a>) <span class="math display">\[
\frac{??? - ???}{\Delta t} = D \left( \frac{??? - ??? + ???}{\Delta x^2} \right).
\]</span> Be sure that your indexing is correct: the superscript <span class="math inline">\(n\)</span> is the index for time and the subscript <span class="math inline">\(i\)</span> is the index for space.</p></li>
<li><p>Rearrange your result from part (c) to solve for <span class="math inline">\(U_i^{n+1}\)</span>: <span class="math display">\[
\begin{aligned} U_i^{n+1} = ??? + \frac{D \Delta t}{\Delta x^2} \left( ??? - ??? + ??? \right). \end{aligned}
\]</span> The iterative scheme which you just derived is called the <strong>forward difference scheme</strong> for the heat equation. Notice that the term on the left is the only term at the next time step <span class="math inline">\(n+1\)</span>. So, for every spatial point <span class="math inline">\(x_i\)</span> we can build <span class="math inline">\(U_i^{n+1}\)</span> by evaluating the right-hand side of the finite difference scheme.</p></li>
<li><p>The numerical errors made by using the forward difference scheme we just built come from two sources: from the approximation of the time derivative and from the approximation of the second spatial derivative. Fill in the question marks in the powers of the following expression: <span class="math display">\[
\text{Numerical Error} = \mathcal{O}(\Delta t^{???}) + \mathcal{O}(\Delta x^{???}).
\]</span></p></li>
<li><p>Explain what the result from part (e) means in plain English?</p></li>
</ol>
</div>
<hr>
<p>There are many different finite difference schemes due to the fact that there are many different ways to approximate derivatives (See <a href="nmDerivatives.html" class="quarto-xref">Chapter&nbsp;<span>5</span></a>). One convenient way to keep track of which information you are using and what you are calculating in a finite difference scheme is to use a <strong>finite difference stencil image</strong>. <a href="#fig-6.8" class="quarto-xref">Figure&nbsp;<span>9.1</span></a> shows the finite difference stencil for the approximation to the heat equation that you built in the previous exercise. In this figure we are showing that the function values <span class="math inline">\(U_{i-1}^n\)</span>, <span class="math inline">\(U_i^n\)</span>, and <span class="math inline">\(U_{i+1}^n\)</span> at the points <span class="math inline">\(x_{i-1}\)</span>, <span class="math inline">\(x_i\)</span>, and <span class="math inline">\(x_{i+1}\)</span> at time step <span class="math inline">\(t_n\)</span> are used to calculate <span class="math inline">\(U_i^{n+1}\)</span>. We will build similar stencil diagrams for other finite difference schemes throughout this chapter.</p>
<div id="fig-6.8" class="quarto-float quarto-figure quarto-figure-left anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-6.8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/PDE/HeatStencil.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-6.8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9.1: The forward difference stencil for the 1D heat equation.
</figcaption>
</figure>
</div>
<hr>
<div id="exr-6.30" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.2</strong></span> Now we want to implement your answer to part (d) of the previous exercise to approximate the solution to the following problem: Solve <span class="math display">\[
u_t = 0.1u_{xx}
\]</span> on the domain <span class="math inline">\(0 &lt; x &lt; 1\)</span> and <span class="math inline">\(0 &lt; t &lt; 1\)</span> with the initial condition with <span class="math display">\[
u(0,x) = \sin(2 \pi x)
\]</span> and boundary conditions <span class="math display">\[
u(t,0) = 0, \, \text{and} \, u(t,1) = 0.
\]</span> For this purpose divide the <span class="math inline">\(x\)</span> domain into 20 equal pieces and the <span class="math inline">\(t\)</span> domain into 100 equal pieces.</p>
<p>Some partial code is given below to get you started.</p>
<ul>
<li>First we import the proper libraries, set up the time domain, and set up the spatial domain.</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ipywidgets <span class="im">import</span> interactive</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Write code to give a vector of times starting at t=0 and ending </span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># at t=1 that divides the interval into 100 equal pieces.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the step size `dt`.</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Write code to give a vector of x values starting at x=0 and </span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co"># ending exactly at x=1 that divides the interval into 20 equal pieces.</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the step size `dx`.</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Specify the diffusion coefficient</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> <span class="fl">0.01</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co"># The coefficient "a" appears in the forward difference scheme.</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> D<span class="op">*</span>dt <span class="op">/</span> dx<span class="op">**</span><span class="dv">2</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"dt="</span>, dt, <span class="st">", dx="</span>, dx, <span class="st">" and D dt/dx^2="</span>, a)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>Next we build the array <span class="math inline">\(U\)</span> so we can store all of the approximations at all times and at all spatial points. The array will have the dimensions <code>len(t)</code> by <code>len(x)</code>. We then need to enforce the boundary conditions so for all times we fill the proper portions of the array with the proper boundary conditions. Lastly, we will build the initial condition for all spatial steps in the first time step.</li>
</ul>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> np.zeros((<span class="bu">len</span>(t),<span class="bu">len</span>(x)))</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>U[:,<span class="dv">0</span>] <span class="op">=</span> <span class="co"># left boundary condition</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>U[:,<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="co"># right boundary condition</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>U[<span class="dv">0</span>,:] <span class="op">=</span> <span class="co"># the function for the init. condition (should depend on x)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>Now we step through a loop that fills the <span class="math inline">\(U\)</span> array one row at a time. Keep in mind that we want to leave the boundary conditions fixed so we will only fill indices <code>1</code> through <code>-2</code> (stop and explain this). Be careful to get the indexing correct. For example, if we want <span class="math inline">\(U_i^n\)</span> we use <code>U[n,1:-1]</code>, if we want <span class="math inline">\(U_{i+1}^n\)</span> we use <code>U[n,2:]</code>, if we want <span class="math inline">\(U_i^{n+1}\)</span> we use <code>U[n+1,1:-1]</code>, etc.</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(t)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    U[n<span class="op">+</span><span class="dv">1</span>,<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> U[n,?:?] <span class="op">+</span> a<span class="op">*</span>( U[n,?:] <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>U[n,?:?] <span class="op">+</span> U[n,:?])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>It remains to visualise the solutions. You can either make a plot or an animation to illustrate the time evolution of <span class="math inline">\(u\)</span>. For each of these there a various Python packages you could use. Below is a function <code>plot_solution_1d()</code> using plotly to make a plot and a function <code>animate_solution_1d()</code> using matplotlib to make an animated 2D plot. You can use either of these or you can use your own plotting code.</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.graph_objects <span class="im">as</span> go</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_solution_1d(t, x, U):</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Plots the numerical approximation to a function u(t,x).</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">        t: A vector of time values.</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">        x: A vector of spatial values.</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">        U: A 2D array approximating the solution u(x,t) at each grid point.</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    fig <span class="op">=</span> go.Figure(data<span class="op">=</span>[go.Surface(z<span class="op">=</span>U, x<span class="op">=</span>x, y<span class="op">=</span>t)])</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    fig.update_layout(</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        width<span class="op">=</span><span class="dv">800</span>, height<span class="op">=</span><span class="dv">600</span>,</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        scene<span class="op">=</span><span class="bu">dict</span>(</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            yaxis_title<span class="op">=</span><span class="st">'t'</span>,</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            zaxis_title<span class="op">=</span><span class="st">'u'</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fig</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> animation, rc</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> HTML</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> animate_solution_1d(t, x, U):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Animates the numerical approximation to a function u(t,x).</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">        t: A vector of time values.</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">        x: A vector of spatial values.</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">        U: A 2D array approximating the solution u(x,t) at each grid point.</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    ax.grid()</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">"x"</span>)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">"u"</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    ax.set_xlim((np.<span class="bu">min</span>(x), np.<span class="bu">max</span>(x)))</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    ax.set_ylim((np.<span class="bu">min</span>(U), np.<span class="bu">max</span>(U)))</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    frame, <span class="op">=</span> ax.plot([], [], linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Don't display every time</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    step <span class="op">=</span> <span class="bu">int</span>(<span class="bu">len</span>(t)<span class="op">/</span><span class="dv">30</span>)<span class="op">+</span><span class="dv">1</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    frames <span class="op">=</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">int</span>(<span class="bu">len</span>(t)<span class="op">/</span>step), <span class="dv">1</span>)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> animator(i):</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> i<span class="op">*</span>step</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="ss">f"t = </span><span class="sc">{</span>t[n]<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        frame.set_data(x, U[n,:])</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (frame, )</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>    ani <span class="op">=</span> animation.FuncAnimation(fig, animator, frames<span class="op">=</span>frames, interval<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>    rc(<span class="st">'animation'</span>, html<span class="op">=</span><span class="st">'jshtml'</span>) <span class="co"># embed in the HTML for Google Colab</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ani</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<div id="exr-heat1d" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.3</strong></span> 🎓 Now wrap up your code for solving the one-dimensional heat equation as a function so that you can easily call it with different parameters.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> heat1d(u_0, D<span class="op">=</span><span class="fl">0.1</span>, t_0<span class="op">=</span><span class="dv">0</span>, t_max<span class="op">=</span><span class="dv">1</span>, N_t<span class="op">=</span><span class="dv">100</span>, x_left<span class="op">=</span><span class="dv">0</span>, x_right<span class="op">=</span><span class="dv">1</span>, N_x<span class="op">=</span><span class="dv">20</span>):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Solves the 1D heat equation using the forward difference method.</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">    This function solves the 1D heat equation with given initial and </span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">    boundary conditions. It also prints a diagnostic message stating</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">    the step sizes `dt` and `dx` used and the value of `a = D*dt/dx**2`.</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">        u_0: A function giving the initial condition u(0,x).</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">        D: The diffusion coefficient. Defaults to 1.</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">        t_0: The initial time. Defaults to 0.</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co">        t_max: The maximum time. Defaults to 1.</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co">        N_t: The number of time steps. Defaults to 100.</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="co">        x_left: The left boundary of the spatial domain. Defaults to 0.</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="co">        x_right: The right boundary of the spatial domain. Defaults to 1.</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co">        N_x: The number of spatial steps. Defaults to 20.</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="co">        A tuple containing the following:</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="co">            t: A vector of time values.</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="co">            x: A vector of spatial values.</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="co">            U: A 2D array approximating the solution u(t,x) at each grid point.</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Your code goes here</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Use your function to solve the heat equation with diffusion coefficient <span class="math inline">\(D=0.1\)</span> and the following initial and boundary conditions: <span class="math display">\[
u(0,x) = \sin(2 \pi x), \, u(t,0) = 0, \, \text{and} \, u(t,1)
\]</span> Use stepsizes <span class="math inline">\(\Delta t=0.01\)</span> and <span class="math inline">\(\Delta x=0.01\)</span> to determine an approximate value for <span class="math inline">\(u(0.2,0.25)\)</span>.</p>
</div>
<hr>
<div id="exr-6.31a" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.4</strong></span> Now run the solution method from the previous exercise with the same diffusion coefficient <span class="math inline">\(D=0.1\)</span>, the same step sizes <span class="math inline">\(\Delta t=0.01\)</span> and <span class="math inline">\(\Delta x=0.01\)</span>, and the same initial and boundary conditions but run it for a longer time <span class="math inline">\(t=0.5\)</span> and plot the solution on the domain <span class="math inline">\(t\in[0,0.5]\)</span> and <span class="math inline">\(x\in[0,1]\)</span>. Do you believe what you see? What is happening to the solution?</p>
</div>
<hr>
<div id="exr-6.31" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.5</strong></span> 🎓 You will have found that you did not get a sensible solution from your method for the previous problem. The point of this exercise is to show that value of <span class="math inline">\(a = D\frac{\Delta t}{\Delta x^2}\)</span> controls the stability of the forward difference solution to the heat equation, and furthermore that there is a threshold for <span class="math inline">\(a\)</span> above which the forward difference scheme will be unstable. Experiment with values of <span class="math inline">\(\Delta t\)</span> and <span class="math inline">\(\Delta x\)</span> and conjecture the values of <span class="math inline">\(a = D \frac{\Delta t}{\Delta x^2}\)</span> that give a stable result. Your conjecture should take the form:</p>
<p><em>If</em> <span class="math inline">\(a = D\frac{\Delta t}{\Delta x^2} &lt; \underline{\hspace{0.5in}}\)</span> then the forward difference solution for the 1D heat equation is stable. Otherwise it is unstable.</p>
<p>Hint: the threshold is a simple fraction. If you think you have found a value for <span class="math inline">\(a\)</span> at which the method is stable, run the simulation for longer (while keeping the same <span class="math inline">\(\Delta t\)</span>) to check that it is really stable. Close to the threshold the errors grow more slowly (albeit still exponentially).</p>
</div>
<hr>
<div id="exr-6.32" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.6</strong></span> Consider the one dimensional heat equation with diffusion coefficient <span class="math inline">\(D=1\)</span>: <span class="math display">\[
u_t = u_{xx}.
\]</span> We want to solve this equation on the domain <span class="math inline">\(x \in [0,1]\)</span> and <span class="math inline">\(t\in [0,0.1]\)</span> subject to the initial condition <span class="math inline">\(u(0,x) = \sin(\pi x)\)</span> and the boundary conditions <span class="math inline">\(u(t,0)=u(t,1) = 0\)</span>.</p>
<ol type="a">
<li><p>Show that the function <span class="math inline">\(u(t,x) = e^{-\pi^2 t} \sin(\pi x)\)</span> is a solution to this heat equation, satisfies the initial condition, and satisfies the boundary conditions.</p></li>
<li><p>Pick values of <span class="math inline">\(\Delta t\)</span> and <span class="math inline">\(\Delta x\)</span> so that you can get a stable forward difference solution to this heat equation. Then make a plot of your numerical solution.</p></li>
<li><p>Compare your plot to the plot of the exact solution that you can get with</p></li>
</ol>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>X, T <span class="op">=</span> np.meshgrid(x, t)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>u_exact <span class="op">=</span> np.exp(<span class="op">-</span>np.pi<span class="op">**</span><span class="dv">2</span><span class="op">*</span>T)<span class="op">*</span>np.sin(np.pi<span class="op">*</span>X)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>plot_solution_1d(t, x, u_exact)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<div id="exr-6.32b" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.7</strong></span> 🎓 Now let us change the initial condition to <span class="math inline">\(u(0,x)=\sin(\pi x) + \sin(3 \pi x)\)</span>. We will keep the same boundary conditions as before: <span class="math inline">\(u(t,0)=u(t,1)=0\)</span>.</p>
<ol type="a">
<li><p>Show that the function <span class="math inline">\(u(t,x) = e^{-\pi^2 t} \sin(\pi x) +  e^{-9\pi^2t}\sin(3\pi x)\)</span> is a solution to this heat equation, matches this new initial condition, and matches the boundary conditions.</p></li>
<li><p>Pick values of <span class="math inline">\(\Delta t\)</span> and <span class="math inline">\(\Delta x\)</span> so that you can get a stable forward difference solution to this heat equation. Make a 3d plot of your numerical solution.</p></li>
<li><p>Compare your plot to the plot of the exact solution.</p></li>
</ol>
</div>
<hr>
</section>
<section id="sec-neumann" class="level3" data-number="9.2.2">
<h3 data-number="9.2.2" class="anchored" data-anchor-id="sec-neumann"><span class="header-section-number">9.2.2</span> Different Boundary Conditions</h3>
<p>In any initial and boundary value problem such as the heat equation, the boundary are often of Dirichlet or Neumann type. In Dirichlet boundary conditions the values of the solution at the boundary are specified. In contrast, Neumann boundary conditions specify the flux at the boundary instead of the value of the solution.</p>
<div id="exr-6.34" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.8 (Time-dependent Dirichlet Boundary Condition)</strong></span> Modify your 1D heat equation code to plot an approximate solution of the diffusion equation <span class="math inline">\(u_t = 0.5 u_{xx}\)</span> with <span class="math inline">\(x \in (0,1)\)</span>, <span class="math inline">\(u(0,x) = \sin(2\pi x)\)</span>, <span class="math inline">\(u(t,0) = 0\)</span> and <span class="math inline">\(u(t,1) = \sin(5\pi t)\)</span>.</p>
</div>
<hr>
<div id="exr-6.33" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.9 (Neumann Boundary Condition)</strong></span> 🎓 Consider the 1D heat equation <span class="math inline">\(u_t = u_{xx}\)</span> with boundary conditions <span class="math inline">\(u_x(t,0)=0\)</span> and <span class="math inline">\(u(t,1)=0\)</span> with initial condition <span class="math inline">\(u(0,x) = \cos(\pi x/2)\)</span>. Notice that the initial condition satisfies both boundary conditions: <span class="math inline">\(\frac{d}{dx}(\cos(\pi \cdot x/2))\Big|_{x=0} = 0\)</span> and <span class="math inline">\(\cos(\pi \cdot 1/2)=0\)</span>. As the heat profile evolves in time the Neumann boundary condition <span class="math inline">\(u_x(t,0)=0\)</span> says that the slope of the solution needs to be fixed at 0 at the left-hand boundary.</p>
<ol type="a">
<li><p>Draw several images of what the solution to the PDE should look like as time evolves. Be sure that all boundary conditions are satisfied and that your solution appears to solve the heat equation.</p></li>
<li><p>The Neumann boundary condition <span class="math inline">\(u_x(t,0) = 0\)</span> can be approximated with the first order approximation <span class="math display">\[
u_x(t_n,0) \approx \frac{U_1^n - U_0^n}{\Delta x} \text{ for all } n.
\]</span> If we set this approximation to 0 (since <span class="math inline">\(u_x(t,0)=0\)</span>) and solve for <span class="math inline">\(U_0^n\)</span> we get an additional constraint at every time step of the numerical solution to the heat equation: <span class="math display">\[ U_0^n = ??? \text{ for all } n.\]</span></p></li>
<li><p>Modify your 1D heat equation code to implement this Neumann boundary condition, plot the numerical solution and verify visually that the Neumann boundary is satisfied.</p></li>
</ol>
</div>
</section>
<section id="sec-heat2d" class="level3" data-number="9.2.3">
<h3 data-number="9.2.3" class="anchored" data-anchor-id="sec-heat2d"><span class="header-section-number">9.2.3</span> In Two Spatial Dimensions</h3>
<p>Now we transition to the two dimensional heat equation. Instead of thinking of this as heating a long metal rod we can think of heating a thin plate of metal (like a flat cookie sheet). The heat equation models the propagation of the heat energy throughout the 2D surface. In two spatial dimensions the heat equation is <span class="math display">\[
\frac{\partial u}{\partial t} = D \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} \right),
\]</span> or, using subscript notation for the partial derivatives, <span class="math display">\[
u_t = D\left( u_{xx} + u_{yy} \right).
\]</span></p>
<hr>
<div id="exr-6.35" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.10</strong></span> Let us build a numerical solution to the 2D heat equation. We need to make a minor modification to our notation since there is now one more spatial dimension to keep track of. Let <span class="math inline">\(U_{i,j}^n\)</span> be the approximation to <span class="math inline">\(u\)</span> at the point <span class="math inline">\((t_n, x_i, y_j)\)</span>. For example, <span class="math inline">\(U_{2,3}^4\)</span> will be the approximation to the solution at the point <span class="math inline">\((t_4,x_2,y_3)\)</span>.</p>
<ol type="a">
<li><p>We already know how to approximate the time derivative in the heat equation: <span class="math display">\[
u_t(t_{n}, x_i, y_j) \approx \frac{U_{i,j}^{n+1} - U_{i,j}^n}{\Delta t}.
\]</span> The new challenge now is that we have two spatial partial derivatives: one in <span class="math inline">\(x\)</span> and one in <span class="math inline">\(y\)</span>. Use what you learned in <a href="nmDerivatives.html" class="quarto-xref">Chapter&nbsp;<span>5</span></a> to write the approximations of <span class="math inline">\(u_{xx}\)</span> and <span class="math inline">\(u_{yy}\)</span>. <span class="math display">\[
u_{xx}(t_n,x_i,y_j) \approx \frac{??? - ??? + ???}{\Delta x^2}
\]</span> <span class="math display">\[
u_{yy}(t_n,x_i,y_j) \approx \frac{??? - ??? + ???}{\Delta y^2}
\]</span> Take careful note that the index <span class="math inline">\(i\)</span> is the only one that changes for the <span class="math inline">\(x\)</span> derivative. Similarly, the index <span class="math inline">\(j\)</span> is the only one that changes for the <span class="math inline">\(y\)</span> derivative.</p></li>
<li><p>Put your answers to part (a) together with the 2D heat equation <span class="math display">\[
\frac{U_{i,j}^{n+1} - U_{i,j}^n}{\Delta t} = D \left( \frac{??? - ??? + ???}{\Delta x^2} + \frac{??? - ??? + ???}{\Delta y^2} \right).
\]</span></p></li>
<li><p>Let us make one simplifying assumption. Choose the partition of the domain so that <span class="math inline">\(\Delta x = \Delta y\)</span>. Note that we can usually do this in square domains. In more complicated domains we will need to be more careful. Simplify the right-hand side of your answer to part (b) under this assumption. <span class="math display">\[
\frac{U_{i,j}^{n+1} - U_{i,j}^n}{\Delta t} = D \left( \frac{??? + ??? - ??? + ??? + ???}{???} \right).
\]</span></p></li>
<li><p>Now solve your result from part (c) for <span class="math inline">\(U_{i,j}^{n+1}\)</span>. Your answer is the explicit forward difference scheme for the 2D heat equation. <span class="math display">\[
U_{i,j}^{n+1} = U_{???,???}^{???} + \frac{D \cdot ???}{???} \left( ??? + ??? - ??? + ??? + ??? \right)
\]</span></p></li>
</ol>
</div>
<hr>
<p>The finite difference stencil for the 2D heat equation is a bit more complicated since we now have three indices to track. Hence, the stencil is naturally three dimensional. <a href="#fig-6.9" class="quarto-xref">Figure&nbsp;<span>9.2</span></a> shows the stencil for the forward difference scheme that we built in the previous exercise. The left-hand subplot in the figure shows the five points used in time step <span class="math inline">\(t_n\)</span>, and the right-hand subplot shows the one point that is calculated at time step <span class="math inline">\(t_{n+1}\)</span>.</p>
<div id="fig-6.9" class="quarto-float quarto-figure quarto-figure-left anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-6.9-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/PDE/HeatStencil2D.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-6.9-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9.2: The finite difference stencil for the 2D heat equation.
</figcaption>
</figure>
</div>
<hr>
<div id="exr-6.36" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.11</strong></span> Now we need to implement the finite difference scheme that you developed in the previous problem. As a model problem, consider the 2D heat equation <span class="math inline">\(u_t = D(u_{xx} + u_{yy})\)</span> on the domain <span class="math inline">\((x,y) \in [0,1] \times [0,1]\)</span> with the initial condition <span class="math inline">\(u(0,x,y) = \sin(\pi x)\sin(\pi y)\)</span>, Dirichlet boundary conditions <span class="math inline">\(u(t,x,0) = u(t,x,1)=u(t,0,y)=u(t,1,y)=0\)</span>, and <span class="math inline">\(D=1\)</span>. Fill in the holes in the following code chunks.</p>
<ul>
<li>First we import the proper libraries and set up the domains for <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, and <span class="math inline">\(t\)</span>.</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> cm <span class="co"># this allows for color maps </span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ipywidgets <span class="im">import</span> interactive</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Write code to build a linearly spaced array of x values </span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co"># starting at 0 and ending at exactly 1</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="co"># your code here</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> x <span class="co"># this could be generalised later</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co"># The consequence of the previous line is that dy = dx.</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> <span class="co"># Extract dx from your array of x values.</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Now write code to build a linearly spaced array of time values </span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co"># starting at 0 and ending at 0.1.</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co"># You will want to use many more values for time than for space </span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co"># (think about the stability conditions from the 1D heat equation).</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="co"># your code here</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> <span class="co"># Extract dt from your array of t values</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Next we will use the np.meshgrid() command to turn the arrays of </span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="co"># x and y values into 2D grids of x and y values.  </span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="co"># If you match the corresponding entries of X and Y then you get </span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="co"># every ordered pair in the domain.</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>Y, X <span class="op">=</span> np.meshgrid(y, x)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Next we set up a 3 dimensional array of zeros to store all of </span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="co"># the time steps of the solutions.</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> np.zeros((<span class="bu">len</span>(t), <span class="bu">len</span>(x), <span class="bu">len</span>(y)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>Next we have to set up the boundary and initial conditions for the given problem.</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>U[<span class="dv">0</span>,:,:] <span class="op">=</span> <span class="co"># initial condition depending on X and Y</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>U[:,<span class="dv">0</span>,:] <span class="op">=</span> <span class="co"># boundary condition for x=0</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>U[:,<span class="op">-</span><span class="dv">1</span>,:] <span class="op">=</span> <span class="co"># boundary condition for x=1</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>U[:,:,<span class="dv">0</span>] <span class="op">=</span> <span class="co"># boundary condition for y=0</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>U[:,:,<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="co"># boundary condition for y=1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>We know that the value of <span class="math inline">\(D \Delta t / \Delta x^2\)</span> controls the stability of the forward difference method. Therefore, the next step in our code is to calculate this value and print it.</li>
</ul>
<div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> D<span class="op">*</span>dt<span class="op">/</span>dx<span class="op">**</span><span class="dv">2</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>Next for the part of the code that actually calculates all of the time steps. Be sure to keep the indexing straight. Also be sure that we are calculating all of the spatial indices <em>inside</em> the domain since the boundary conditions dictate what happens on the boundary.</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(t)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  U[n<span class="op">+</span><span class="dv">1</span>,<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> U[n,<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    a<span class="op">*</span>(U[n, ?:? , ?:?] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>       U[n, ?:?, ?:?] <span class="op">-</span> <span class="op">\</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>       <span class="dv">4</span><span class="op">*</span>U[n, ?:?, ?:?] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>       U[n, ?:?, ?:?] <span class="op">+</span> <span class="op">\</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>       U[n, ?:?, ?:?])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>Finally, we just need to visualize the solution. We can no longer make a plot of <span class="math inline">\(u\)</span> against <span class="math inline">\(t, x\)</span> and <span class="math inline">\(y\)</span> because that would require four dimensions. So we will animate the solution. You can use the following function:</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> animation</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> HTML</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> animate_solution_2d(t, x, y, U):</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    Y, X <span class="op">=</span> np.meshgrid(y, x)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set up the figure and axis</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    fig <span class="op">=</span> plt.figure()</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> fig.add_subplot(<span class="dv">111</span>, projection<span class="op">=</span><span class="st">'3d'</span>)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize the surface plot</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    surface <span class="op">=</span> [ax.plot_surface(X, Y, U[<span class="dv">0</span>, :, :], cmap<span class="op">=</span><span class="st">'viridis'</span>)]</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Don't display every time</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    step <span class="op">=</span> <span class="bu">int</span>(<span class="bu">len</span>(t)<span class="op">/</span><span class="dv">30</span>)<span class="op">+</span><span class="dv">1</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    frames <span class="op">=</span> <span class="bu">int</span>(<span class="bu">len</span>(t)<span class="op">/</span>step)</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> animate(i):</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> i<span class="op">*</span>step</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update the data of the surface plot for each frame</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>        ax.clear()  <span class="co"># Clear the previous frame</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>        surface[<span class="dv">0</span>] <span class="op">=</span> ax.plot_surface(X, Y, U[n, :, :], cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>        ax.set_zlim(np.<span class="bu">min</span>(U), np.<span class="bu">max</span>(U))</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="ss">f"Time: </span><span class="sc">{</span>t[n]<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create animation</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>    ani <span class="op">=</span> animation.FuncAnimation(fig, animate, frames<span class="op">=</span>frames, repeat<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Display the animation</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> HTML(ani.to_jshtml())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<div id="exr-6.37" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.12</strong></span> 🎓 Time to do some experimentation with your new 2D heat equation code! Numerically solve the 2D heat equation with different boundary conditions (both Dirichlet and Neumann). Be prepared to present your solutions.</p>
</div>
<hr>
<div id="exr-6.2db" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.13</strong></span> In order for the forward difference solution to the 2D heat equation on a square domain to be stable we need <span class="math inline">\(D \Delta t / \Delta x^2 &lt; \underline{\hspace{0.5in}}\)</span>.</p>
<p>Experiment with several parameters to empirically determine the bound.</p>
</div>
<hr>
<div id="exr-6.38" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.14</strong></span> Now solve the 2D heat equation on a rectangular domain. You will need to make some modifications to your code since it is unlikely that assuming that <span class="math inline">\(\Delta x = \Delta y\)</span> is a good assumption any longer. Again, be prepared to present your solutions.</p>
</div>
<hr>
</section>
<section id="sec-heatvar" class="level3" data-number="9.2.4">
<h3 data-number="9.2.4" class="anchored" data-anchor-id="sec-heatvar"><span class="header-section-number">9.2.4</span> Variations on the Heat Equation</h3>
<p>The heat equation is a parabolic PDE and the forward-difference method that we have developed can be adapted to work for other parabolic PDEs.</p>
<section id="sec-rde" class="level4" data-number="9.2.4.1">
<h4 data-number="9.2.4.1" class="anchored" data-anchor-id="sec-rde"><span class="header-section-number">9.2.4.1</span> Reaction-Diffusion Equations</h4>
<p>For example, the heat equation can be modified to include a reaction term. The reaction-diffusion equation is a PDE that models the diffusion of a substance in space and time with a reaction term that describes the rate of change of the substance due to some reaction. While it has its origin in chemistry, it shows up in many other fields as well, for example in ecology and epidemiology.</p>
<div id="exr-6.34" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.15 (Fisher-KPP Equation)</strong></span> 🎓 Modify your 1D heat equation code to calculate an approximate solution of the Fisher-KPP equation <span class="math display">\[
u_t = u_{xx} +u(1-u)
\]</span> with <span class="math inline">\(t\in[0,10]\)</span>, <span class="math inline">\(x \in (0,50)\)</span>, boundary conditions <span class="math display">\[
u(t,0) = 0,\ \ \ \ u(t,50) = 1
\]</span> and initial condition <span class="math display">\[
u(0,x) = \frac{1+\tanh\left(\dfrac{x-40}{2}\right)}{2}.
\]</span> Use <code>animate_solution_1d()</code> to visualize the solution. How does the solution change as time evolves?</p>
</div>
<hr>
</section>
<section id="sec-advect" class="level4" data-number="9.2.4.2">
<h4 data-number="9.2.4.2" class="anchored" data-anchor-id="sec-advect"><span class="header-section-number">9.2.4.2</span> Advective-Diffusion Equations</h4>
<p>The diffusion term usually arises from random spatial motion of particles. However, in some cases the particles are advected by a flow field. In this case we need to add an advection term to the diffusion equation. The advection-diffusion equation is a PDE that models the diffusion of a substance in space and time with an advection term that describes the rate of change of the substance due to some flow field.</p>
<div id="exr-6.34b" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.16</strong></span> 🎓 Modify your 1D heat equation code to plot an approximate solution of the following simple advection-diffusion equation: <span class="math display">\[
u_t = 0.1 u_{xx} - u_x
\]</span> Use the forward difference formula for the <span class="math inline">\(u_x\)</span> term and the centred difference formula for the <span class="math inline">\(u_{xx}\)</span> term. Use the initial condition <span class="math inline">\(u(0,x) = \sin(\pi x)\)</span>, Dirichlet boundary conditions <span class="math inline">\(u(t,0) = 0\)</span> and <span class="math inline">\(u(t,1) = 0\)</span>, and <span class="math inline">\(t\in[0,1]\)</span>. Use <span class="math inline">\(20\)</span> spatial steps and <span class="math inline">\(100\)</span> time steps. Make a plot and an animation of the solution.</p>
</div>
<hr>
</section>
</section>
<section id="sec-heat_stability" class="level3" data-number="9.2.5">
<h3 data-number="9.2.5" class="anchored" data-anchor-id="sec-heat_stability"><span class="header-section-number">9.2.5</span> Implicit Methods</h3>
<p>Let us summarize the stability criteria for the forward difference solutions to the heat equation.</p>
<ul>
<li><p>In the 1D heat equation the forward difference solution is stable if <span class="math inline">\(D \Delta t / \Delta x^2 &lt; \underline{\hspace{0.5in}}\)</span>.</p></li>
<li><p>In the 2D heat equation the forward difference solution is stable if <span class="math inline">\(D \Delta t / \Delta x^2 &lt; \underline{\hspace{0.5in}}\)</span>&nbsp;(assuming a square domain where <span class="math inline">\(\Delta x = \Delta y\)</span>)</p></li>
</ul>
<div id="exr-6.39" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.17 (Sawtooth Errors)</strong></span> We have already seen that the 1D heat equation is stable if <span class="math inline">\(D \Delta t / \Delta x^2 &lt; 0.5\)</span>. The goal of this problem is to show what, exactly, occurs when we choose parameters in the unstable region. We will solve the PDE <span class="math inline">\(u_t = u_{xx}\)</span> on the domain <span class="math inline">\(x \in [0,1]\)</span> with initial conditions <span class="math inline">\(u(0,x) = \sin(\pi x)\)</span> and homogeneous Dirichlet boundary conditions <span class="math inline">\(u(t,0)=u(t,1)=0\)</span> for all <span class="math inline">\(t\in[0,0.25]\)</span>. The analytic solution is <span class="math inline">\(u(t,x) = e^{-\pi^2 t}\sin(\pi x)\)</span>. To build the spatial and temporal grid use 20 spatial steps and 100 time steps. This means that <span class="math inline">\(\Delta x = 0.05\)</span> and <span class="math inline">\(\Delta t = 0.0025\)</span> so the ratio <span class="math inline">\(D \Delta t / \Delta x^2 = 1 &gt; 0.5\)</span> (certainly in the unstable region). Solve the heat equation with your <code>heat1d()</code> function using these parameters. Make plots of the approximate solution on top of the exact solution at time steps 0, 10, 20, 30, 31, 32, 33, 34, etc. Describe what you observe.</p>
</div>
<hr>
<div id="exr-6.40" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.18 (Hedgehog Errors)</strong></span> Solve the 2D heat equation on the unit square with homogeneous Dirichlet boundary conditions with the following parameters:</p>
<ul>
<li><p>A diffusion coefficient of <span class="math inline">\(D=1\)</span>;</p></li>
<li><p>A partition of 21 points in both the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> direction;</p></li>
<li><p>301 points between 0 and 0.25 for time;</p></li>
<li><p>An initial condition of <span class="math inline">\(u(0,x,y) = \sin(\pi x) \sin(\pi y)\)</span>.</p></li>
</ul>
<p>What happens near time step number 70?</p>
</div>
<hr>
<p>It is actually possible to beat the stability criteria given in the previous exercises! What follows are two implicit methods that use a forward-looking scheme to help completely avoid unstable solutions. The primary advantage to these schemes is that we will not need to pay as close attention to the ratio of the time step to the square of the spatial step. Instead, we can take time and spatial steps that are appropriate for the application we have in mind.</p>
<hr>
<div id="exr-6.43" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.19 (Backward Difference Scheme)</strong></span> 🎓 For the 1D heat equation <span class="math inline">\(u_t = D u_{xx}\)</span> we have been finding the numerical solution using the explicit finite difference scheme <span class="math display">\[
\frac{U_i^{n+1} - U_i^n}{\Delta t} = D \frac{U_{i+1}^{n} - 2U_i^{n} + U_{i-1}^{n}}{\Delta x^2}
\]</span> where we approximate the spatial derivative with the centred difference and the time derivative with the usual forward difference. If, however, we use the backward difference formula for the time derivative we get the finite difference scheme <span class="math display">\[
\frac{U_i^{n} - U_i^{n-1}}{\Delta t} = D \frac{U_{i+1}^{n} - 2U_i^{n} + U_{i-1}^{n}}{\Delta x^2}.
\]</span> or, shifting to the next timestep, <span class="math display">\[
\frac{U_i^{n+1} - U_i^n}{\Delta t} = D \frac{U_{i+1}^{n+1} - 2U_i^{n+1} + U_{i-1}^{n+1}}{\Delta x^2}.
\]</span> This may seem completely ridiculous since we do not yet know the information at time step <span class="math inline">\(n+1\)</span> but some algebraic rearrangement shows that we can treat this as a system of linear equations which can be solved (using something like <code>np.linalg.solve()</code>) for the <span class="math inline">\((n+1)^{st}\)</span> time step.</p>
<p>We again introduce the coefficient <span class="math inline">\(a = D \Delta t / \Delta x^2.\)</span> This will save a little bit of writing in the coming steps.</p>
<ol type="1">
<li><p>Rearrange the new finite difference scheme so that all of the terms at the <span class="math inline">\((n+1)^{st}\)</span> time step are on the left-hand side and all of the term at the <span class="math inline">\(n^{th}\)</span> time step are on the right-hand side. <span class="math display">\[
(\underline{\hspace{0.25in}}) U_{i-1}^{n+1} + (\underline{\hspace{0.5in}}) U_{i}^{n+1} + (\underline{\hspace{0.25in}}) U_{i+1}^{n+1} = U_i^n
\]</span></p></li>
<li><p>Now we are going to build a very small example with only 6 spatial points so that you can clearly see the structure of the resulting linear system.</p>
<ol type="a">
<li><p>If we have 6 total points in the spatial grid (<span class="math inline">\(x_0, x_1, \ldots, x_5\)</span>) then we have the following equations (fill in the blanks): <span class="math display">\[
\begin{aligned} (\text{for $x_1$: }) \quad \underline{\hspace{0.25in}} U_0^{n+1} + \underline{\hspace{0.5in}} U_1^{n+1} + \underline{\hspace{0.25in}} U_2^{n+1} &amp;= U_1^{n} \\ (\text{for $x_2$: }) \quad \underline{\hspace{0.25in}} U_1^{n+1} + \underline{\hspace{0.5in}} U_2^{n+1} + \underline{\hspace{0.25in}} U_3^{n+1} &amp;=  U_2^{n} \\ (\text{for $x_3$: }) \quad \underline{\hspace{0.25in}} U_2^{n+1} + \underline{\hspace{0.5in}} U_3^{n+1} + \underline{\hspace{0.25in}} U_4^{n+1} &amp;=  U_3^{n} \\ (\text{for $x_4$: }) \quad \underline{\hspace{0.25in}} U_3^{n+1} + \underline{\hspace{0.5in}} U_4^{n+1} + \underline{\hspace{0.25in}} U_5^{n+1} &amp;=  U_4^{n} \\ \end{aligned}
\]</span></p></li>
<li><p>Notice that we aready know <span class="math inline">\(U_0^{n+1}\)</span> and <span class="math inline">\(U_5^{n+1}\)</span> since these are dictated by the boundary conditions (assuming Dirichlet boundary conditions). Hence we can move these known quantities to the right-hand side of the equations and hence rewrite the system of equations as: <span class="math display">\[
\begin{aligned}
(\text{for $x_1$: }) &amp; \quad  &amp; \underline{\hspace{0.5in}} U_1^{n+1} &amp;+ \underline{\hspace{0.25in}} U_2^{n+1} &amp;=  U_1^{n} &amp;+ \underline{\hspace{0.25in}} U_0^{n+1}\\
(\text{for $x_2$: }) &amp;\quad  \underline{\hspace{0.25in}} U_1^{n+1} &amp;+ \underline{\hspace{0.5in}} U_2^{n+1} &amp;+ \underline{\hspace{0.25in}} U_3^{n+1} &amp;=  U_2^{n} &amp;\\ (\text{for $x_3$: }) &amp;\quad  \underline{\hspace{0.25in}} U_2^{n+1} &amp;+ \underline{\hspace{0.5in}} U_3^{n+1} &amp;+ \underline{\hspace{0.25in}} U_4^{n+1} &amp;=  U_3^{n}&amp; \\ (\text{for $x_4$: }) &amp;\quad  \underline{\hspace{0.25in}} U_3^{n+1} &amp;+ \underline{\hspace{0.5in}} U_4^{n+1}&amp; &amp;=  U_4^{n} &amp;+ \underline{\hspace{0.25in}} U_5^{n+1} \\ \end{aligned}
\]</span></p></li>
<li><p>Now we can write this as a matrix equation: <span class="math display">\[
\begin{pmatrix} \underline{\hspace{0.25in}} &amp; \underline{\hspace{0.25in}} &amp; 0 &amp; 0 \\ \underline{\hspace{0.25in}} &amp; \underline{\hspace{0.25in}} &amp; \underline{\hspace{0.25in}} &amp; 0 \\ 0 &amp; \underline{\hspace{0.25in}} &amp; \underline{\hspace{0.25in}} &amp; \underline{\hspace{0.25in}} \\ 0 &amp; 0 &amp; \underline{\hspace{0.25in}} &amp; \underline{\hspace{0.25in}} \end{pmatrix}\begin{pmatrix} U_1^{n+1} \\ U_2^{n+1} \\ U_3^{n+1} \\ U_4^{n+1} \end{pmatrix} = \begin{pmatrix} U_1^{n} \\ U_2^{n} \\ U_3^{n} \\ U_4^{n} \end{pmatrix} + \begin{pmatrix} \underline{\hspace{0.25in}} U_0^{n+1} \\ 0 \\ 0 \\ \underline{\hspace{0.25in}} U_5^{n+1} \end{pmatrix}
\]</span></p></li>
</ol></li>
<li><p>At this point the structure of the coefficient matrix on the left and the vector sum on the right should be clear (even for more spatial points). It is time for us to start writing some code. we will start with the basic setup of the problem.</p></li>
</ol>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="co"># set up a linearly spaced spatial domain </span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="co"># set up a linearly spaced temporal domain</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> x[<span class="dv">1</span>]<span class="op">-</span>x[<span class="dv">0</span>]</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> t[<span class="dv">1</span>]<span class="op">-</span>t[<span class="dv">0</span>]</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> D<span class="op">*</span>dt<span class="op">/</span>dx<span class="op">**</span><span class="dv">2</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>IC <span class="op">=</span> <span class="kw">lambda</span> x: <span class="co"># write a function for the initial condition</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>BCleft <span class="op">=</span> <span class="kw">lambda</span> t: <span class="dv">0</span><span class="op">*</span>t <span class="co"># left boundary condition </span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>BCright <span class="op">=</span> <span class="kw">lambda</span> t: <span class="dv">0</span><span class="op">*</span>t <span class="co"># right boundary condition </span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> np.zeros((<span class="bu">len</span>(t), <span class="bu">len</span>(x))) <span class="co"># set up a blank array for U</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>U[<span class="dv">0</span>,:] <span class="op">=</span> IC(x) <span class="co"># set up the initial condition</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>U[:,<span class="dv">0</span>] <span class="op">=</span> BCleft(t) <span class="co"># set up the left boundary condition</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>U[:,<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> BCright(t) <span class="co"># set up the right boundary condition</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="4" type="1">
<li>Next we write a function that takes in the number of spatial points and returns the coefficient matrix for the linear system. Take note that the first and last rows take a little more care than the rest.</li>
</ol>
<div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> coeffMatrix(M,a): <span class="co"># we are using M=len(x) as the first input</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  A <span class="op">=</span> np.zeros((M<span class="op">-</span><span class="dv">2</span>, M<span class="op">-</span><span class="dv">2</span>))</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># why are we using M-2 x M-2 for the size?</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  A[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="co"># top left entry</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  A[<span class="dv">0</span>,<span class="dv">1</span>] <span class="op">=</span> <span class="co"># entry in the first row second column</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  A[<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="co"># bottom right entry</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  A[<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">2</span>] <span class="op">=</span> <span class="co"># entry in the last row second to last column</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,M<span class="op">-</span><span class="dv">3</span>): <span class="co"># now loop through all of the other rows</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    A[i,i] <span class="op">=</span> <span class="co"># entry on the main diagonal</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    A[i,i<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="co"># entry on the lower diagonal</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    A[i,i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> <span class="co"># entry on the upper diagonal</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> A</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> coeffMatrix(<span class="bu">len</span>(x),a)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>plt.spy(A) </span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="co"># spy is a handy plotting tool that shows the structure </span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="co"># of a matrix (optional)</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="5" type="1">
<li>Next we write a loop that iteratively solves the system of equations for each new time step.</li>
</ol>
<div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(t)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  b1 <span class="op">=</span> U[n,???] </span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># b1 is a vector of U at step n for the inner spatial nodes</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  b2 <span class="op">=</span> np.zeros(length(b1)) <span class="co"># set up the second right-hand vector</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  b2[<span class="dv">0</span>] <span class="op">=</span> ???<span class="op">*</span>BCleft(t[n<span class="op">+</span><span class="dv">1</span>]) <span class="co"># fill in the correct first entry</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  b2[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> ???<span class="op">*</span>BCright(t[n<span class="op">+</span><span class="dv">1</span>]) <span class="co"># fill in the correct last entry</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  b <span class="op">=</span> b1 <span class="op">+</span> b2 <span class="co"># The vector "b" is the right side of the equation</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># </span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># finally use a linear algebra solver to fill in the </span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># inner spatial nodes at step n+1</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  U[n<span class="op">+</span><span class="dv">1</span>,???] <span class="op">=</span> ???</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="6" type="1">
<li><p>All of the hard work is now done. It remains to plot the solution. Try this method on several sets of initial and boundary conditions for the 1D heat equation. Be sure to demonstrate that the method is stable no matter the values of <span class="math inline">\(\Delta t\)</span> and <span class="math inline">\(\Delta x\)</span>.</p></li>
<li><p>What are the primary advantages and disadvantages to the implicit method described in this problem?</p></li>
</ol>
</div>
<hr>
<div id="exr-6.44" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.20 (The Crank-Nicolson Method)</strong></span> 🎓 We conclude this section with one more implicit scheme: the <strong>Crank-Nicolson Method</strong>. In this method we take the average of the forward and backward difference schemes: <span class="math display">\[
\frac{U_i^{n+1} - U_i^n}{\Delta t} = \frac{1}{2} \left[D \left( \frac{U_{i-1}^n - 2U_i^n + U_{i+1}^n}{\Delta x^2}\right) +D \left(\frac{U_{i-1}^{n+1} - 2U_i^{n+1} + U_{i+1}^{n+1}}{\Delta x^2} \right) \right].
\]</span> Letting <span class="math inline">\(r = D \Delta t / (2\Delta x^2)\)</span> we can rearrange to get <span class="math display">\[
\underline{\hspace{0.25in}} U_{i-1}^{n+1} + \underline{\hspace{0.25in}} U_{i}^{n+1} + \underline{\hspace{0.25in}} U_{i+1}^{n+1} = \underline{\hspace{0.25in}} U_{i-1}^{n} + \underline{\hspace{0.25in}} U_{i}^{n} + \underline{\hspace{0.25in}} U_{i+1}^{n}.
\]</span> This can now be viewed as a system of equations. Let us build this system carefully and then write code to solve the heat equation from the previous problems with the Crank-Nicolson method. For this problem we will assume fixed Dirichlet boundary conditions on both the left- and right-hand sides of the domain.</p>
<ol type="1">
<li><p>First let us write the equations for several values of <span class="math inline">\(i\)</span>. <span class="math display">\[
\begin{aligned} (\text{$x_1$ }): \quad \underline{\hspace{0.15in}} U_0^{n+1} + \underline{\hspace{0.15in}} U^{n+1}_1 + \underline{\hspace{0.15in}} U^{n+1}_2 &amp;= \underline{\hspace{0.15in}}U^n_0 + \underline{\hspace{0.15in}} U^n_1 + \underline{\hspace{0.15in}}U^n_2 \\ (\text{$x_2$ }): \quad \underline{\hspace{0.15in}} U_1^{n+1} + \underline{\hspace{0.15in}} U^{n+1}_2 + \underline{\hspace{0.15in}}U^{n+1}_3 &amp;= \underline{\hspace{0.15in}}U^n_1 + \underline{\hspace{0.15in}} U^n_2 + \underline{\hspace{0.15in}}U^n_3 \\ (\text{$x_3$ }): \quad \underline{\hspace{0.15in}} U_2^{n+1} + \underline{\hspace{0.15in}} U^{n+1}_3 + \underline{\hspace{0.15in}}U^{n+1}_4 &amp;= \underline{\hspace{0.15in}}U^n_2 + \underline{\hspace{0.15in}} U^n_3 + \underline{\hspace{0.15in}}U^n_4 \\ \qquad \vdots &amp; \qquad \vdots \\ (\text{$x_{M-2}$ }): \quad \underline{\hspace{0.1in}} U_{M-3}^{n+1} + \underline{\hspace{0.1in}} U^{n+1}_{M-2} + \underline{\hspace{0.1in}}U^{n+1}_{M-1} &amp;= \underline{\hspace{0.1in}}U^n_{M-3} + \underline{\hspace{0.1in}} U^n_{M-2} + \underline{\hspace{0.1in}}U^n_{M-1} \end{aligned}
\]</span> where <span class="math inline">\(M\)</span> is the number of spatial points (enumerated <span class="math inline">\(x_0, x_1, x_2, \ldots, x_{M-1}\)</span>).</p></li>
<li><p>The first and last equations can be simplified since we are assuming that we have Dirichlet boundary conditions. Therefore for <span class="math inline">\(x_1\)</span> we can rearrange to move the <span class="math inline">\(U_0^{n+1}\)</span> term to the right-hand side since it is given for all time. Similarly for <span class="math inline">\(x_{M-2}\)</span> we can move the <span class="math inline">\(U_{M-1}^{n+1}\)</span> term to the right-hand side since it is fixed for all time. Rewrite these two equations.</p></li>
<li><p>Verify that the left-hand side of the equations that we have built in parts (1) and (2) can be written as the following matrix-vector product: <span class="math display">\[
\begin{aligned} \begin{pmatrix} (1+2r) &amp; -r &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ -r &amp; (1+2r) &amp; -r &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; -r &amp; (1+2r) &amp; -r &amp; \cdots &amp; 0 \\ \vdots &amp; &amp; &amp; &amp; &amp; 0 \\ 0 &amp; \cdots &amp; &amp; 0 &amp; -r &amp; (1+2r) \end{pmatrix} \begin{pmatrix} U^{n+1}_1 \\ U^{n+1}_2 \\ U^{n+1}_3 \\ \vdots \\U^{n+1}_{M-2} \end{pmatrix} \end{aligned}
\]</span></p></li>
<li><p>Verify that the right-hand side of the equations that we built in parts (1) and (2) can be written as <span class="math display">\[
\begin{pmatrix} (1-2r) &amp; r &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ r &amp; (1-2r) &amp; r &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; r &amp; (1-2r) &amp; r &amp; &amp; 0 \\ \vdots &amp; &amp; &amp; &amp; &amp; \\ &amp; &amp; &amp; &amp; r &amp; (1-2r) \end{pmatrix} \begin{pmatrix} U^{n}_1 \\ U^{n}_2 \\ U_3^n \\ \vdots \\U^{n}_{M-2} \end{pmatrix}\\ + \begin{pmatrix} r(U_0^{n+1}+U_0^{n}) \\ 0 \\ \vdots \\ 0 \\ r(U_{M-1}^{n}+U_{M-1}^{n+1}) \end{pmatrix}
\]</span></p></li>
<li><p>Now for the wonderful part! The entire system of equations from part (a) can be written as <span class="math display">\[
A \mathcal{U}^{n+1} = B \mathcal{U}^n + D.
\]</span> What are the matrices <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> and what are the vectors <span class="math inline">\(\mathcal{U}^{n+1}\)</span>, <span class="math inline">\(\mathcal{U}^n\)</span>, and <span class="math inline">\(D\)</span>?</p></li>
<li><p>To solve for <span class="math inline">\(\mathcal{U}^{n+1}\)</span> at each time step we simply need to do a linear solve: <span class="math display">\[
\mathcal{U}^{n+1} = A^{-1} \left( B \mathcal{U}^n + D \right).
\]</span> Of course, we will never do a matrix inverse on a computer. Instead we can lean on tools such as <code>np.linalg.solve()</code> to do the linear solve for us.</p></li>
<li><p>Finally. Write code to solve the 1D Heat Equation implementing the Crank Nicolson method described in this problem. The setup of your code should be largely the same as for the implicit method from <a href="#exr-6.43" class="quarto-xref">Exercise&nbsp;<span>9.19</span></a>. You will need to construct the matrices <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> as well as the vector <span class="math inline">\(D\)</span>. Then your time stepping loop will contain the code from part 6 of this problem.</p></li>
</ol>
</div>
<hr>
<div id="exr-6.45" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.21</strong></span> To graphically show the Crank Nicolson method we can again use a finite difference stencil to show where the information is coming from and where it is going to. In <a href="#fig-6.10" class="quarto-xref">Figure&nbsp;<span>9.3</span></a> notice that there are three points at the new time step that are used to calculate the value of <span class="math inline">\(U_i^{n+1}\)</span> at the new time step. Sketch a similar image for the original implicit scheme from <a href="#exr-6.43" class="quarto-xref">Exercise&nbsp;<span>9.19</span></a></p>
<div id="fig-6.10" class="quarto-float quarto-figure quarto-figure-left anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-6.10-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/PDE/HeatStencilCrankNicolson.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-6.10-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9.3: The finite difference stencil for the Crank Nicolson method.
</figcaption>
</figure>
</div>
</div>
<p>It turns out that the error terms for the forward and backward difference methods have the form <span class="math inline">\(C\Delta t+O(\Delta t^2)\)</span> and <span class="math inline">\(C\Delta t+O(\Delta t^2)\)</span>. Taking the average cancels the <span class="math inline">\(\pm C\Delta t\)</span> terms and leaves an error of order <span class="math inline">\(O(\Delta t^2)\)</span>; in combination with the space variable, we have an error of order <span class="math inline">\(O(\Delta t^2)+O(\Delta x^2)\)</span> for the whole method, as compared with <span class="math inline">\(O(\Delta t)+O(\Delta x^2)\)</span> for the forward and backward difference methods. Like the backward difference method, the Crank-Nicolson method is absolutely stable.</p>
</section>
<section id="sec-stability-heat" class="level3" data-number="9.2.6">
<h3 data-number="9.2.6" class="anchored" data-anchor-id="sec-stability-heat"><span class="header-section-number">9.2.6</span> Stability</h3>
<p>While exploring the explicit finite-difference method for solving the 1d heat equation <span class="math inline">\(u_t=Du_{xx}\)</span> we encountered the stability condition <span class="math display">\[
a=\frac{D\Delta t}{(\Delta x)^2}\leq \frac{1}{2}.
\]</span> We now want to understand where this condition comes from.</p>
<p>We start by setting up the notation for solving the heat equation using the explicit finite-difference method. We discretise the spatial variable <span class="math inline">\(x\)</span> into <span class="math inline">\(N\)</span> intervals with grid points <span class="math inline">\(x_0,\ldots,x_N\)</span> with stepsize <span class="math inline">\(\Delta x=(x_N-x_0)/N\)</span>. We discretise the time variable <span class="math inline">\(t\)</span> into <span class="math inline">\(M\)</span> intervals with grid points <span class="math inline">\(t_0,\ldots,t_M\)</span> with stepsize <span class="math inline">\(\Delta t=(t_M-t_0)/M\)</span>. We denote the approximation of <span class="math inline">\(u(t_n,x_i)\)</span> by <span class="math inline">\(U_i^n\)</span>. The initial condition sets <span class="math inline">\(U_i^0=u(t_0,x_i)\)</span>. We work with homogeneous Dirichlet boundary conditions, so <span class="math inline">\(U_0^n=U_N^n=0\)</span> for all <span class="math inline">\(n\)</span>.</p>
<p>The approximations at the remaining points is then calculated by the formula <span class="math display">\[
U_i^{n+1}=U_i^n+a(U_{i+1}^n-2U_i^n+U_{i-1}^n)
\]</span> for <span class="math inline">\(i=1,\ldots,N-1\)</span>. You derived this in <a href="#sec-heat1d" class="quarto-xref"><span>Section 9.2.1</span></a> using the finite-difference formulae for the derivatives from <a href="nmDerivatives.html" class="quarto-xref"><span>Chapter 5</span></a>. We rewrite this in matrix notation: <span class="math display">\[
\begin{pmatrix}U_1^{n+1}\\\vdots\\U_{N-1}^{n+1}\end{pmatrix}=\begin{pmatrix}1-2a&amp;a&amp;&amp;\\
a&amp;1-2a&amp;a&amp;&amp;\\
&amp;\ddots&amp;\ddots&amp;\ddots&amp;\\
&amp;&amp;a&amp;1-2a\end{pmatrix}\begin{pmatrix}U_1^{n}\\\vdots\\U_{N-1}^{n}\end{pmatrix}.
\]</span> The matrix is tridiagonal, with <span class="math inline">\(1-2a\)</span> on the diagonal and <span class="math inline">\(a\)</span> on the two off-diagonals. We denote the matrix by <span class="math inline">\(A\)</span> and the two vectors by <span class="math inline">\(\mathbf{U}_{n+1}\)</span> and <span class="math inline">\(\mathbf{U}_{n}\)</span> respectively. So we have the formula <span class="math display">\[
\mathbf{U}_{n+1}=A\mathbf{U}_n.
\]</span> The solution at time <span class="math inline">\(t_n\)</span> is then given by <span class="math display">\[
\mathbf{U}_n=A^n\mathbf{U}_0.
\]</span></p>
<p>We want to understand how errors evolve over time. If errors grow exponentially over time then we call the method unstable and the method is not useful.</p>
<p>Let us assume that at some step, for convenience let us choose step <span class="math inline">\(0\)</span>, an error <span class="math inline">\(\mathbf{\epsilon}\)</span> is introduced: <span class="math display">\[
\tilde{\mathbf{U}}_0=\mathbf{U}_0+\mathbf{\epsilon}.
\]</span> Then after <span class="math inline">\(n\)</span> steps we have <span class="math display">\[
\tilde{\mathbf{U}}_n=A^n\tilde{\mathbf{U}}_0=A^n(\mathbf{U}_0+\mathbf{\epsilon})=A^n\mathbf{U}_0+A^n\mathbf{\epsilon}=\mathbf{U}_n+A^n\mathbf{\epsilon}.
\]</span> So the error at time <span class="math inline">\(t_n\)</span> is <span class="math display">\[
\mathbf{\epsilon}_n=A^n\mathbf{\epsilon}.
\]</span> To see if the error grows exponentially over time, we expand the initial error in terms of the eigenvectors of the matrix <span class="math inline">\(A\)</span>: <span class="math display">\[
\mathbf{\epsilon}=\sum_i\epsilon_i\mathbf{v}_i,
\]</span> where <span class="math display">\[
A\mathbf{v}_i=\lambda_i\mathbf{v}_i
\]</span> and the sum is over all eigenvectors <span class="math inline">\(\mathbf{v}_i\)</span> of <span class="math inline">\(A\)</span>. Then <span class="math display">\[
\mathbf{\epsilon}^n=\sum_i\epsilon_i\lambda_i^n\mathbf{v}_i.
\]</span> This shows that if all eigenvalues have absolute value less than 1, then the method is stable. If at least one eigenvalue has absolute value greater than 1, then the corresponding component of the error will grow exponentially with time and the method is unstable.</p>
<p>The eigenvalues of the matrix <span class="math inline">\(A\)</span> are the roots of the characteristic polynomial <span class="math display">\[
\det(A-\lambda I)=0.
\]</span></p>
<p>There is a nice method to determine the eigenvalues of the matrix <span class="math inline">\(A\)</span>, using Fourier analysis. We will not discuss this in this module and instead just give the result and then look at a simple example. The result (which you do not need to remember) is that the eigenvalues of the matrix <span class="math inline">\(A\)</span> are given by <span class="math display">\[
\lambda_k=1-4a\left(\sin\left(\frac{k\pi}{2N}\right)\right)^2
\]</span> for <span class="math inline">\(k=1,\ldots,N-1\)</span>. For stability we need <span class="math inline">\(|\lambda_k|&lt;1\)</span> for all <span class="math inline">\(k\)</span>, i.e., <span class="math display">\[
0\leq a\left(\sin\left(\frac{k\pi}{2N}\right)\right)^2\leq\frac12
\]</span> for all <span class="math inline">\(k\)</span>. The most stringent condition is that coming from <span class="math inline">\(k=N-1\)</span>, so the stability condition is <span class="math display">\[
a\leq \frac{1}{2}\left(\sin\left(\frac{(N-1)\pi}{2N}\right)\right)^{-2}.
\]</span></p>
<p>In the limit <span class="math inline">\(N\to\infty\)</span> this gives the condition <span class="math inline">\(a\leq 1/2\)</span>.</p>
<div id="exm-heat_stability" class="theorem example">
<p><span class="theorem-title"><strong>Example 9.1</strong></span> Consider the heat equation on the spatial domain <span class="math inline">\(x\in[0,1]\)</span> and divide this into three subintervals, so that our spatial grid consists of <span class="math inline">\(x_0=0,x_1=1/3,x_2=2/3\)</span> and <span class="math inline">\(x_3=1\)</span>. The matrix <span class="math inline">\(A\)</span> is then <span class="math display">\[
A=\begin{pmatrix}1-2a&amp;a&amp;\\
a&amp;1-2a
\end{pmatrix}.
\]</span> The characteristic polynomial is <span class="math display">\[
\begin{split}
\det(A-\lambda I)&amp;=\begin{vmatrix}1-2a-\lambda&amp;a\\
a&amp;1-2a-\lambda
\end{vmatrix}\\
&amp;=(1-2a-\lambda)^2-a^2\\
&amp;=\lambda^2-2(1-2a)\lambda+(1-2a)^2-a^2.
\end{split}
\]</span> The roots of this polynomial are <span class="math display">\[
\lambda_\pm=1-2a\pm a.
\]</span> We need both of these to have a magnitude less than 1 for the method to be stable. This gives us an upper bound on the allowed <span class="math inline">\(a\)</span>. The eigenvalue whose magnitude will increase above <span class="math inline">\(1\)</span> first as <span class="math inline">\(a\)</span> increases is <span class="math inline">\(\lambda_-=1-3a\)</span>, which has magnitude <span class="math inline">\(1\)</span> when <span class="math inline">\(a=2/3\)</span>. So the stability condition is <span class="math inline">\(a\leq 2/3\)</span>.</p>
</div>
</section>
</section>
<section id="the-wave-equation" class="level2" data-number="9.3">
<h2 data-number="9.3" class="anchored" data-anchor-id="the-wave-equation"><span class="header-section-number">9.3</span> The Wave Equation</h2>
<p>Any material below this point is optional and will not be assessed.</p>
<p>The problems that we have dealt with thus far all model natural diffusion processes: heat transport, molecular diffusion, etc. Another interesting physical phenomenon is that of wave propagation. The 1D <em>wave equation</em> is <span class="math display">\[
u_{tt} = c^2 u_{xx}
\]</span> where <span class="math inline">\(c\)</span> is a parameter modelling the stiffness of the medium the wave is travelling through. With homogeneous Dirichlet boundary conditions we can think of this as the behaviour of a guitar string after it has been plucked. If the boundaries are in motion then the model might be of someone wiggling a taught string from one end.</p>
<hr>
<div id="exr-6.46" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.22</strong></span> Let us write code to numerically solve the 1D wave equation. As before, we use the notation <span class="math inline">\(U_i^n\)</span> to represent the approximate solution <span class="math inline">\(u(t,x)\)</span> at the point <span class="math inline">\(t=t_n\)</span> and <span class="math inline">\(x=x_i\)</span>.</p>
<ol type="1">
<li><p>Give a reasonable discretization of the second derivative in time: <span class="math display">\[
u_{tt}(t_{n}, x_i) \approx \underline{\hspace{1in}}.
\]</span></p></li>
<li><p>Give a reasonable discretization of the second derivative in space: <span class="math display">\[
u_{xx}(t_n, x_i) \approx \underline{\hspace{1in}}.
\]</span></p></li>
<li><p>Put your answers to parts (a) and (b) together with the wave equation to get <span class="math display">\[
\frac{??? - ??? + ???}{\Delta t^2} = c^2 \frac{??? - ??? + ???}{\Delta x^2}.
\]</span></p></li>
<li><p>Solve the equation from part 3 for <span class="math inline">\(U_i^{n+1}\)</span>. The resulting difference equation is the finite difference scheme for the 1D wave equation.</p></li>
<li><p>You should notice that the finite difference scheme for the wave equation references two different times: <span class="math inline">\(U_i^n\)</span> and <span class="math inline">\(U_i^{n-1}\)</span>. Based on this observation, what information do we need to in order to actually start our numerical solution?</p></li>
<li><p>Consider the wave equation <span class="math inline">\(u_{tt} = 2 u_{xx}\)</span> in <span class="math inline">\(x \in (0,1)\)</span> with <span class="math inline">\(u(0,x) = 4x(1-x)\)</span>, <span class="math inline">\(u_t(0,x) = 0\)</span>, and <span class="math inline">\(u(t,0) = u(t,1) = 0\)</span>. Use the finite difference scheme that you built in this problem to approximate the solution to this PDE.</p></li>
</ol>
</div>
<hr>
<p><a href="#fig-6.11" class="quarto-xref">Figure&nbsp;<span>9.4</span></a> shows the finite difference stencil for the 1D wave equation. Notice that we need two prior time steps in order to advance to the new time step. This means that in order to start the finite difference scheme for the wave equation we need to have information about time <span class="math inline">\(t_0\)</span> and also time <span class="math inline">\(t_1\)</span>. We get this information by using the two initial conditions <span class="math inline">\(u(0,x)\)</span> and <span class="math inline">\(u_t(0,x)\)</span>.</p>
<div id="fig-6.11" class="quarto-float quarto-figure quarto-figure-left anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-6.11-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/PDE/WaveStencil.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-6.11-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9.4: The finite difference stencil for the 1D wave equation.
</figcaption>
</figure>
</div>
<hr>
<div id="exr-6.47" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.23</strong></span> The ratio <span class="math inline">\(c^2\Delta t^2 / \Delta x^2\)</span> shows up explicitly in the finite difference scheme for the 1D wave equation. Just like in the heat equation, this parameter controls when the finite difference solution will be stable. Experiment with your finite difference solution and conjecture a value of <span class="math inline">\(a = c^2 \Delta t^2 / \Delta x^2\)</span> which divides the regions of stability versus instability. Your answer should be in the form:</p>
<p><em>If</em> <span class="math inline">\(a = c^2\Delta t^2 / \Delta x^2 &lt; \underline{\hspace{0.5in}}\)</span> then the finite difference scheme for the 1D wave equation will be stable. Otherwise it will be unstable.</p>
</div>
<hr>
<div id="exr-6.48" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.24</strong></span> Show several plots demonstrating what occurs to the finite difference solution of the wave equation when the parameters are in the unstable region and right on the edge of the unstable region.</p>
</div>
<hr>
<div id="exr-6.49" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.25</strong></span> What is the expected error in the finite difference scheme for the 1D wave equation? What does this mean in plain English?</p>
</div>
<hr>
<div id="exr-6.50" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.26</strong></span> Use your finite difference code to solve the 1D wave equation <span class="math display">\[
u_{tt} = c^2 u_{xx}
\]</span> with boundary conditions <span class="math inline">\(u(t,0) = u(t,1) = 0\)</span>, initial condition <span class="math inline">\(u(0,x) = 4x(1-x)\)</span>, and zero initial velocity. Experiment with different values of <span class="math inline">\(c^2\)</span>. What does the parameter <span class="math inline">\(c\)</span> do to the wave? Give a physical interpretation of <span class="math inline">\(c\)</span>.</p>
</div>
<hr>
<div id="exr-6.51" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.27</strong></span> Solve the 1D wave equation <span class="math display">\[
u_{tt} = u_{xx}
\]</span> with Dirichlet boundary conditions <span class="math inline">\(u(t,0) = 0.4 \sin(\pi t)\)</span> and <span class="math inline">\(u(t,1) = 0\)</span> along with initial condition <span class="math inline">\(u(0,x) = 0\)</span> and zero initial velocity. This time the left-hand boundary is being controlled externally and the string starts off at equilibrium. Give a physical situation where this sort of setup might arise. Then modify your solution so that both sides of the string are being wiggled at different frequencies.</p>
</div>
<hr>
<div id="exr-6.52" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.28</strong></span> Now consider the 2D wave equation <span class="math display">\[
u_{tt} = c^2\left( u_{xx} + u_{yy} \right).
\]</span> We want to build a numerical solution to this new PDE. Just like with the 2D heat equation we propose the notation <span class="math inline">\(U_{i,j}^n\)</span> for the approximation of the function <span class="math inline">\(u(t,x,y)\)</span> at the point <span class="math inline">\(t=t_n\)</span>, <span class="math inline">\(x=x_i\)</span>, and <span class="math inline">\(y=y_j\)</span>.</p>
<ol type="1">
<li><p>Give discretizations of the derivatives <span class="math inline">\(u_{tt}\)</span>, <span class="math inline">\(u_{xx}\)</span>, and <span class="math inline">\(u_{yy}\)</span>.</p></li>
<li><p>Substitute your discretizations into the 2D wave equation, make the simplifying assumption that <span class="math inline">\(\Delta x = \Delta y\)</span>, and solve for <span class="math inline">\(U_{i,j}^{n+1}\)</span>. This is the finite difference scheme for the 2D wave equation.</p></li>
<li><p>Write code to implement the finite difference scheme from part 2 on the domain <span class="math inline">\((x,y) \in (0,1)\times (0,1)\)</span> with homogeneous Dirichlet boundary conditions, initial condition <span class="math inline">\(u(0,x,y) = \sin(2\pi (x-0.5))\sin(2\pi(y-0.5))\)</span>, and zero initial velocity.</p></li>
<li><p>Draw the finite difference stencil for the 2D heat equation.</p></li>
</ol>
</div>
<hr>
<div id="exr-6.53" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.29</strong></span> What is the region of stability for the finite difference scheme on the 2D wave equation? Produce several plots showing what happens when we are in the unstable region as well as when we are right on the edge of the stable region.</p>
</div>
<hr>
<div id="exr-6.54" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.30</strong></span> Solve the 2D wave equation on the unit square with <span class="math inline">\(u\)</span> starting at rest and being driven by a wave coming in from one boundary.</p>
</div>
</section>
<section id="the-travelling-wave-equation" class="level2" data-number="9.4">
<h2 data-number="9.4" class="anchored" data-anchor-id="the-travelling-wave-equation"><span class="header-section-number">9.4</span> The Travelling Wave Equation</h2>
<p>Now we turn our attention to a new PDE: the transport equation <span class="math display">\[
u_t + v u_x = 0.
\]</span></p>
<p>In this equation <span class="math inline">\(u(t,x)\)</span> is the height of a wave at time <span class="math inline">\(t\)</span> and spatial location <span class="math inline">\(x\)</span>. The parameter <span class="math inline">\(v\)</span> is the velocity of the wave. Imagine this as sending a single solitary wave pulsing down a taught rope or as sending a single pulse of light down a fibre optic cable.</p>
<hr>
<div id="exr-6.55" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.31</strong></span> Consider the PDE <span class="math inline">\(u_t + v u_x = 0\)</span>. There is a very easy way to get an analytic solution to this equation that describes a travelling wave. If we have the initial condition <span class="math inline">\(u(0,x) = f(x) = e^{-(x-4)^2}\)</span> then we claim that <span class="math inline">\(u(t,x) = f(x-vt)\)</span> is an analytic solution to the PDE. More explicitly, we are claiming that <span class="math display">\[
u(t,x) = e^{-(x-vt-4)^2}
\]</span> is the analytic solution to the PDE. Let us prove this.</p>
<ol type="1">
<li><p>Take the <span class="math inline">\(t\)</span> derivative of <span class="math inline">\(u(t,x)\)</span>.</p></li>
<li><p>Take the <span class="math inline">\(x\)</span> derivative of <span class="math inline">\(u(t,x)\)</span>.</p></li>
<li><p>The PDE claims that <span class="math inline">\(u_t + vu_x = 0\)</span>. Verify that this equal sign is indeed true.</p></li>
</ol>
</div>
<hr>
<div id="exr-6.56" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.32</strong></span> Now we would like to visualize the solution to the PDE from the previous exercise. The Python code below gives an interactive visual of the solution. Experiment with different values of <span class="math inline">\(v\)</span> and different initial conditions.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> animation, rc</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> HTML</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="kw">lambda</span> x: np.exp(<span class="op">-</span>(x<span class="op">-</span><span class="dv">4</span>)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> <span class="kw">lambda</span> t, x: f(x <span class="op">-</span> v<span class="op">*</span>t)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">10</span>,<span class="dv">101</span>)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">10</span>,<span class="dv">101</span>)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>plt.close()</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>ax.grid()</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'x'</span>)</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(( <span class="dv">0</span>, <span class="dv">10</span>))</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(( <span class="op">-</span><span class="fl">0.1</span>, <span class="dv">1</span>))</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>frame, <span class="op">=</span> ax.plot([], [], linewidth<span class="op">=</span><span class="dv">2</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> animator(N):</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>  ax.set_title(<span class="ss">f"Time = </span><span class="sc">{</span>t[N]<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>  frame.set_data(x,???) <span class="co"># plot the correct time step for u(t,x)</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (frame,)</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>PlotFrames <span class="op">=</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(t),<span class="dv">1</span>) </span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>anim <span class="op">=</span> animation.FuncAnimation(fig, </span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>                               animator, </span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>                               frames<span class="op">=</span>PlotFrames, </span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>                               interval<span class="op">=</span><span class="dv">100</span>, </span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>                              )</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>rc(<span class="st">'animation'</span>, html<span class="op">=</span><span class="st">'jshtml'</span>) <span class="co"># embed in the HTML for Google Colab</span></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>anim</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<div id="exr-6.57" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.33</strong></span> Use the chain rule to prove that for any differentiable function <span class="math inline">\(f(x)\)</span> the function <span class="math inline">\(u(t,x) = f(x-vt)\)</span> is an analytic solution to the transport equation <span class="math inline">\(u_t + v u_{x} = 0\)</span> with initial condition <span class="math inline">\(u(0,x) = f(x)\)</span>.</p>
</div>
<hr>
<p>Thus the travelling wave equation <span class="math inline">\(u_t + vu_x = 0\)</span> has a very nice analytic solution which we can always find. Therefore there is no need to ever find a numerical solution – we can just write down the analytic solution if we are given the initial condition. As it turns out though, the numerical solutions exhibit some very interesting behaviour.</p>
<hr>
<div id="exr-6.58" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.34</strong></span> Consider the travelling wave equation <span class="math inline">\(u_t + vu_x = 0\)</span> with initial condition <span class="math inline">\(u(0,x) = f(x)\)</span> for some given function <span class="math inline">\(f\)</span> and boundary condition <span class="math inline">\(u(t,0) = 0\)</span>. To build a numerical solution we will again adopt the notation <span class="math inline">\(U_i^n\)</span> for the approximation to <span class="math inline">\(u(t,x)\)</span> at the point <span class="math inline">\(t=t_n\)</span> and <span class="math inline">\(x=x_i\)</span>.</p>
<ol type="a">
<li><p>Write an approximation of <span class="math inline">\(u_t\)</span> using <span class="math inline">\(U_i^{n+1}\)</span> and <span class="math inline">\(U_i^n\)</span>.</p></li>
<li><p>Write an approximation of <span class="math inline">\(u_x\)</span> using <span class="math inline">\(U_{i+1}^n\)</span> and <span class="math inline">\(U_i^n\)</span>.</p></li>
<li><p>Substitute your answers from parts (a) and (b) into the travelling wave equation and solve for <span class="math inline">\(U_i^{n+1}\)</span>. This is our first finite difference scheme for the travelling wave equation.</p></li>
<li><p>Write Python code to get the finite difference approximation of the solution to the PDE. Plot your finite difference solution on top of the analytic solution for <span class="math inline">\(f(x) = e^{-(x-4)^2}\)</span>. What do you notice? Can you stabilize this method by changing the values of <span class="math inline">\(\Delta t\)</span> and <span class="math inline">\(\Delta x\)</span> like with did with the heat and wave equations?</p></li>
</ol>
</div>
<hr>
<p>The finite difference scheme that you built in the previous exercise is called the downwind scheme for the travelling wave equation. <a href="#fig-6.12" class="quarto-xref">Figure&nbsp;<span>9.5</span></a> shows the finite difference stencil for this scheme. We call this scheme “downwind” since we expect the wave to travel from left to right and we can think of a fictitious wind blowing the solution from left to right. Notice that we are using information from “downwind” of the point at the new time step.</p>
<div id="fig-6.12" class="quarto-float quarto-figure quarto-figure-left anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-6.12-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/PDE/DownwindStencil.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-6.12-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9.5: The finite difference stencil for the 1D downwind scheme on the traveling wave equation.
</figcaption>
</figure>
</div>
<hr>
<div id="exr-6.59" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.35</strong></span> You should have noticed in the previous exercise that you cannot reasonably stabilize the finite difference scheme. Propose several reasons why this method appears to be unstable no matter what you use for the ratio <span class="math inline">\(v \Delta t / \Delta x\)</span>.</p>
</div>
<hr>
<div id="exr-6.60" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.36</strong></span> One of the troubles with the finite difference scheme that we have built for the travelling wave equation is that we are using the information at our present spatial location and the next spatial location to the right to propagate the solution forward in time. The trouble here is that the wave is moving from left to right, so the interesting information about the next time step’s solution is actually coming from the left, not the right. We call this “looking upwind” since you can think of a fictitious <em>wind</em> blowing from left to right, and we need to look “upwind” to see what is coming at us. If we write the spatial derivative as <span class="math display">\[
u_x \approx \frac{U_i^n - U_{i-1}^n}{\Delta x}
\]</span> we still have a first-order approximation of the derivative but we are now looking left instead of right for our spatial derivative. Make this modification in your finite difference code for the travelling wave equation (call it the “upwind method”). Approximate the solution to the same PDE as we worked with in the previous exercises. What do you notice now?</p>
</div>
<hr>
<p><a href="#fig-6.13" class="quarto-xref">Figure&nbsp;<span>9.6</span></a> shows the finite difference stencil for the upwind scheme. We call this scheme “up” since we expect the wave to travel from left to right and we can think of a fictitious wind blowing the solution from left to right. Notice that we are using information from “upwind” of the point at the new time step.</p>
<div id="fig-6.13" class="quarto-float quarto-figure quarto-figure-left anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-6.13-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/PDE/UpwindStencil.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-6.13-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9.6: The finite difference stencil for the 1D downwind scheme on the traveling wave equation.
</figcaption>
</figure>
</div>
<hr>
<div id="exr-6.61" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.37</strong></span> Complete the following sentences:</p>
<ol type="1">
<li><p>In the downwind finite difference scheme for the travelling wave equation, the approximate solution moves at the correct speed, but …</p></li>
<li><p>In the upwind finite difference scheme for the travelling wave equation, the approximate solution moves at the correct speed, but …</p></li>
</ol>
</div>
<hr>
<div id="exr-6.62" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.38</strong></span> Neither the downwind nor the upwind solutions for the travelling wave equation are satisfactory. They completely miss the interesting dynamics of the analytic solution to the PDE. Some ideas for stabilizing the finite difference solution for the travelling wave equation are as follows. Implement each of these ideas and discuss pros and cons of each. Also draw a finite difference stencil for each of these methods.</p>
<ol type="1">
<li><p>Perhaps one of the issues is that we are using first-order methods to approximate <span class="math inline">\(u_t\)</span> and <span class="math inline">\(u_x\)</span>. What if we used a second-order approximation for these first derivatives <span class="math display">\[
u_t \approx \frac{U_i^{n+1} - U_i^{n-1}}{2\Delta t} \quad \text{ and } \quad u_x \approx \frac{U_{i+1}^n - U_{i-1}^n}{2\Delta x}?
\]</span> Solve for <span class="math inline">\(U_i^{n+1}\)</span> and implement this method. This is called the <strong>leapfrog method.</strong></p></li>
<li><p>For this next method let us stick with the second-order approximation of <span class="math inline">\(u_x\)</span> but we will do something clever for <span class="math inline">\(u_t\)</span>. For the time derivative we originally used <span class="math display">\[
u_t \approx \frac{U_i^{n+1} - U_i^n}{\Delta t}
\]</span> what happens if we replace <span class="math inline">\(U_i^n\)</span> with the average value from the two surrounding spatial points <span class="math display">\[
U_i^n \approx \frac{1}{2} \left( U_{i+1}^n + U_{i-1}^n \right)?
\]</span> This would make our approximation of the time derivative <span class="math display">\[
u_t \approx \frac{U_i^{n+1} - \frac{1}{2} \left( U_{i+1}^n + U_{i-1}^n \right)}{\Delta t}.
\]</span> Solve this modified finite difference equation for <span class="math inline">\(U_i^{n+1}\)</span> and implement this method. This is called the <strong>Lax-Friedrichs</strong> method.</p></li>
<li><p>Finally we will do something very clever (and very counter intuitive). What if we inserted some artificial diffusion into the problem? You know from your work with the heat equation that diffusion spreads a solution out. The downwind scheme seemed to have the issue that it was <em>bunching up</em> at the beginning and end of the wave, so artificial diffusion might smooth this out. The <strong>Lax-Wendroff method</strong> does exactly that: take a regular Euler-type step in time <span class="math display">\[
u_t \approx \frac{U_i^{n+1} - U_i^n}{\Delta t},
\]</span> use a second-order centred difference scheme in space to approximate <span class="math inline">\(u_x\)</span> <span class="math display">\[
u_x \approx \frac{U_{i+1}^n - U_{i-1}^n}{2\Delta x},
\]</span> but add on the term <span class="math display">\[
\left( \frac{v^2 \Delta t^2}{2\Delta x^2} \right) \left( U_{i-1}^n - 2 U_i^n + U_{i+1}^n \right)
\]</span> to the right-hand side of the equation. Notice that this new term is a scalar multiple of the second-order approximation of the second derivative <span class="math inline">\(u_{xx}\)</span>. Solve this equation for <span class="math inline">\(U_i^{n+1}\)</span> and implement the Lax-Wendroff method.</p></li>
</ol>
</div>
</section>
<section id="the-laplace-and-poisson-equations" class="level2" data-number="9.5">
<h2 data-number="9.5" class="anchored" data-anchor-id="the-laplace-and-poisson-equations"><span class="header-section-number">9.5</span> The Laplace and Poisson Equations</h2>
<div id="exr-6.63" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.39</strong></span> Consider the 1D heat equation <span class="math inline">\(u_t = 1 u_{xx}\)</span> with boundary conditions <span class="math inline">\(u(t,0) = 0\)</span> and <span class="math inline">\(u(t,1)=1\)</span> and initial condition <span class="math inline">\(u(0,x) = 0\)</span>.</p>
<ol type="1">
<li><p>Describe the physical setup for this problem.</p></li>
<li><p>Recall that the solution to a differential equation reaches a steady state (or equilibrium) when the time rate of change is zero. Based on the physical system, what is the steady state heat profile for this PDE?</p></li>
<li><p>Use your 1D heat equation code to show the full time evolution of this PDE. Run the simulation long enough so that you see the steady state heat profile.</p></li>
</ol>
</div>
<hr>
<div id="exr-6.64" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.40</strong></span> Now consider the forced 1D heat equation <span class="math inline">\(u_t = u_{xx} + e^{-(x-0.5)^2}\)</span> with the same boundary and initial conditions as the previous exercise. The exponential forcing function introduced in this equation is an external source of heat (like a flame held to the middle of the metal rod).</p>
<ol type="1">
<li><p>Conjecture what the steady state heat profile will look like for this particular setup. Be able to defend your answer.</p></li>
<li><p>Modify your 1D heat equation code to show the full time evolution of this PDE. Run the simulation long enough so that you see the steady state heat profile.</p></li>
</ol>
</div>
<hr>
<div id="exr-6.65" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.41</strong></span> Next we will examine 2D steady state heat profiles. Consider the PDE <span class="math inline">\(u_t = u_{xx} + u_{yy}\)</span> with boundary conditions <span class="math inline">\(u(t,0,y) = u(t,x,0) = u(t,x,1) = 0\)</span> and <span class="math inline">\(u(t,1,y) = 1\)</span> with initial condition <span class="math inline">\(u(0,x,y) = 0\)</span>.</p>
<ol type="1">
<li><p>Describe the physical setup for this problem.</p></li>
<li><p>Based on the physical system, describe the steady state heat profile for this PDE. Be sure that your steady state solution still satisfies the boundary conditions.</p></li>
<li><p>Use your 2D heat equation code to show the full time evolution of this PDE. Run the simulation long enough so that you see the steady state heat profile.</p></li>
</ol>
</div>
<hr>
<div id="exr-6.66" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.42</strong></span> Now consider the forced 2D heat equation <span class="math inline">\(u_t = u_{xx} + u_{yy} + 10e^{-(x-0.5)^2-(y-0.5)^2}\)</span> with the same boundary and initial conditions as the previous exercise. The exponential forcing function introduced in this equation is an external source of heat (like a flame held to the middle of the metal sheet).</p>
<ol type="1">
<li><p>Conjecture what the steady state heat profile will look like for this particular setup. Be able to defend your answer.</p></li>
<li><p>Modify your 2D heat equation code to show the full time evolution of this PDE. Run the simulation long enough so that you see the steady state heat profile.</p></li>
</ol>
</div>
<hr>
<p>Up to this point we have studied PDEs that all depend on time. In many applications, however, we are not interested in the transient (time dependent) behaviour of a system. Instead we are often interested in the steady state solution when the forces in question are in static equilibrium. Two very famous time-independent PDEs are the Laplace Equation <span class="math display">\[
u_{xx} + u_{yy} + u_{zz} = 0
\]</span> and the Poisson equation <span class="math display">\[
u_{xx} + u_{yy} + u_{zz} = f(x,y,z).
\]</span> Notice that both the Laplace and Poisson equations are the equations that we get when we consider the limit <span class="math inline">\(u_t \to 0\)</span>. In the limit when the time rate of change goes to zero we are actually just looking at the eventual steady state heat profile resulting from the initial and boundary conditions of the heat equation. In the previous exercises you already wrote code that will show the steady state profiles in a few setups. The trouble with the approach of letting the time-dependent simulation run for a <em>long time</em> is that the finite difference solution for the heat equation is known to have stability issues. Moreover, it may take a lot of computational time for the solution to reach the eventual steady state. In the remainder of this section we look at methods of solving for the steady state directly – without examining any of the transient behaviour. We will first examine a 1D version of the Laplace and Poisson equations.</p>
<hr>
<div id="exr-6.67" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.43</strong></span> Consider a 1-dimensional rod that is infinitely thin and has unit length. For the sake of simplicity assume the following:</p>
<ul>
<li><p>the specific heat of the rod is exactly 1 for the entire length of the rod,</p></li>
<li><p>the temperature of the left end is held fixed at <span class="math inline">\(u(0) = 0\)</span>,</p></li>
<li><p>the temperature of the right end is held fixed at <span class="math inline">\(u(1) = 1\)</span>, and</p></li>
<li><p>the temperature has reached a steady state.</p></li>
</ul>
<p>You can assume that the temperatures are <em>reference temperatures</em> instead of absolute temperatures, so a temperature of “0” might represent room temperature.</p>
<p>Since there are no external sources of heat we model the steady-state heat profile we must have <span class="math inline">\(u_t = 0\)</span> in the heat equation. Thus the heat equation collapses to <span class="math inline">\(u_{xx} = 0\)</span>. This is exactly the one dimensional Laplace equation.</p>
<ol type="a">
<li><p>To get an exact solution of the Laplace equation in this situation we simply need to integrate twice. Do the integration and write the analytic solution (there should be no surprises here).</p></li>
<li><p>To get a numerical solution we first need to partition the domain into finitely many point. For the sake of simplicity let us say that we subdivide the interval into 5 equal sub intervals (so there are 6 points including the endpoints). Furthermore, we know that we can approximate <span class="math inline">\(u_{xx}\)</span> as <span class="math display">\[
u_{xx} \approx \frac{U_{i+1} - 2U_i + U_{i-1}}{\Delta x^2}.
\]</span> Thus we have 6 linear equations: <span class="math display">\[
\begin{aligned} U_0 &amp;= 1 \quad \text{(left boundary condition)}\\ \frac{U_2 - 2U_1 + U_0}{\Delta x^2} &amp;= 0 \\ \frac{U_3 - 2U_2 + U_1}{\Delta x^2} &amp;= 0 \\ \frac{U_4 - 2U_3 + U_2}{\Delta x^2} &amp;= 0 \\ \frac{U_5 - 2U_4 + U_3}{\Delta x^2} &amp;= 0 \\ U_5 &amp;= 0 \quad \text{(right boundary condition).} \end{aligned}
\]</span> Notice that there are really only four unknowns since the boundary conditions dictate two of the temperature values. Rearrange this system of equations into a matrix equation and solve for the unknowns <span class="math inline">\(U_1\)</span>, <span class="math inline">\(U_2\)</span>, <span class="math inline">\(U_3\)</span>, and <span class="math inline">\(U_4\)</span>. Your coefficient matrix should be <span class="math inline">\(4 \times 4\)</span>.</p></li>
<li><p>Compare your answers from parts (a) and (b).</p></li>
<li><p>Write code to build the numerical solution with an arbitrary value for <span class="math inline">\(\Delta x\)</span> (i.e.&nbsp;an arbitrary number of sub intervals). You should build the linear system automatically in your code.</p></li>
</ol>
</div>
<hr>
<p>Solving the 1D Laplace equation with Dirichlet boundary conditions is rather uninteresting since the answer will always be a linear function connecting the two boundary conditions. The Poisson equation <span class="math inline">\(u_{xx} = f(x)\)</span> is more interesting than the Laplace equation in 1D. The function <span class="math inline">\(f(x)\)</span> is called a forcing function. You can think of it this way: if <span class="math inline">\(u\)</span> is the amount of force on a linear bridge, then <span class="math inline">\(f\)</span> might be a function that gives the distribution of the forces on the bridge due to the cars sitting on the bridge. In terms of heat we can think of this as an external source of heat energy warming up the one-dimensional rod somewhere in the middle (like a flame being held to one place on the rod).</p>
<hr>
<div id="exr-6.69" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.44</strong></span> How would we analytically solve the Poisson equation <span class="math inline">\(u_{xx} = f(x)\)</span> in one spatial dimension? As a sample problem consider <span class="math inline">\(x\in [0,1]\)</span>, the forcing function <span class="math inline">\(f(x) = 5\sin(2 \pi x)\)</span> and boundary conditions <span class="math inline">\(u(0) = 2\)</span> and <span class="math inline">\(u(1) = 0.5\)</span>. Of course you need to check your answer by taking two derivatives and making sure that the second derivative exactly matches <span class="math inline">\(f(x)\)</span>. Also be sure that your solution matches the boundary conditions exactly.</p>
</div>
<hr>
<div id="exr-6.70" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.45</strong></span> Now we can solve the Poisson equation from the previous problem numerically. Let us again build this with a partition that contains only 6 points just like we did with the Laplace equation a few exercise ago. We know the approximation for <span class="math inline">\(u_{xx}\)</span> so we have the linear system <span class="math display">\[
\begin{aligned} U_0 &amp;= 2 \quad \text{(left boundary condition)}\\ \frac{U_2 - 2U_1 + U_0}{\Delta x^2} &amp;= f(x_1) \\ \frac{U_3 - 2U_2 + U_1}{\Delta x^2} &amp;= f(x_2) \\ \frac{U_4 - 2U_3 + U_2}{\Delta x^2} &amp;= f(x_3) \\ \frac{U_5 - 2U_4 + U_3}{\Delta x^2} &amp;= f(x_4) \\ U_5 &amp;= 0.5 \quad \text{(right boundary condition).} \end{aligned}
\]</span></p>
<ol type="a">
<li><p>Rearrange the system of equations as a matrix equation and then solve the system for <span class="math inline">\(U_1, U_2, U_3\)</span>, and <span class="math inline">\(U_4\)</span>. There are really only four equations so your matrix should be <span class="math inline">\(4 \times 4\)</span>.</p></li>
<li><p>Compare your solution from part (a) to the function values that you found in the previous exercise.</p></li>
<li><p>Now generalize the process of solving the 1D Poisson equation for an arbitrary value of <span class="math inline">\(\Delta x\)</span>. You will need to build the matrix and the right-hand side in your code. Test your code on new forcing functions and new boundary conditions.</p></li>
</ol>
</div>
<hr>
<div id="exr-6.71" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.46</strong></span> The previous exercises only account for Dirichlet boundary conditions (fixed boundary conditions). We would now like to modify our Poisson solution to allow for a Neumann condition: where we know the derivative of <span class="math inline">\(u\)</span> at one of the boundaries. The statement of the problem is as follows: <span class="math display">\[
\text{Solve: } u_{xx} = f(x) \quad \text{on} \quad x \in (0,1) \quad \text{with} \quad u_x(0) = \alpha \quad \text{and} \quad u(1) = \beta.
\]</span> The derivative condition on the boundary can be approximated by using a first-order approximation of the derivative, and as a consequence we have one new equation. Specifically, if we know that <span class="math inline">\(u_x(0) = \alpha\)</span> then we can approximate this condition as <span class="math display">\[
\frac{U_1 - U_0}{\Delta x} = \alpha,
\]</span> and we simply need to add this equation to the system that we were solving in the previous exercise. If we go back to our example of a partition with 6 points the system becomes <span class="math display">\[
\begin{aligned} \frac{U_1 - U_0}{\Delta x} &amp;= \alpha \quad \text{(left boundary condition)}\\ \frac{U_2 - 2U_1 + U_0}{\Delta x^2} &amp;= f(x_1) \\ \frac{U_3 - 2U_2 + U_1}{\Delta x^2} &amp;= f(x_2) \\ \frac{U_4 - 2U_3 + U_2}{\Delta x^2} &amp;= f(x_3) \\ \frac{U_5 - 2U_4 + U_3}{\Delta x^2} &amp;= f(x_4) \\ U_5 &amp;= \beta \quad \text{(right boundary condition).} \end{aligned}
\]</span> There are 5 equations this time.</p>
<ol type="a">
<li><p>With a 6 point grid solve the Poisson equation <span class="math inline">\(u_{xx} = 5\sin(2\pi x)\)</span> with <span class="math inline">\(u_x(0) = 0\)</span> and <span class="math inline">\(u(1) = 3\)</span>.</p></li>
<li><p>Modify your code from part (a) to solve the same problem but with a much smaller value of <span class="math inline">\(\Delta x\)</span>. You will need to build the matrix equation in your code.</p></li>
</ol>
</div>
<hr>
<div id="exr-6.72" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.47 (The 2D Poisson Equation)</strong></span> We conclude this section, and chapter, by examining the two dimensional Poisson equations. As a sample problem, we want to solve the Poisson equation <span class="math display">\[u_{xx} + u_{yy} = f(x,y)\]</span> on the domain <span class="math inline">\((x,y) \in (0,1)\times (0,1)\)</span> with homogeneous Dirichlet boundary conditions and forcing function <span class="math display">\[f(x,y) = -20\text{exp}\left( -\frac{(x-0.5)^2 + (y-0.5)^2}{0.05} \right)\]</span> numerically.</p>
<p>We are going to start with a <span class="math inline">\(6 \times 6\)</span> grid of points and explicitly write down all of the equations. In <a href="#fig-6.14" class="quarto-xref">Figure&nbsp;<span>9.7</span></a> the red stars represent boundary points where the value of <span class="math inline">\(u(x,y)\)</span> is known and the blue interior points are the ones where <span class="math inline">\(u(x,y)\)</span> is yet unknown. It should be clear that we should have two indices for each point (one for the <span class="math inline">\(x\)</span> position and one for the <span class="math inline">\(y\)</span> position), but it should also be clear that this will cause problems when writing down the resulting system of equations as a matrix equation (stop and think carefully about this). Therefore, in <a href="#fig-6.14" class="quarto-xref">Figure&nbsp;<span>9.7</span></a> we propose an index, <span class="math inline">\(k\)</span>, starting at the top left of the unknown nodes and reading left to right (just like we do with Python arrays).</p>
<ol type="a">
<li><p>Start by discretizing the 2D Poisson equation <span class="math inline">\(u_{xx} + u_{yy} = f(x,y)\)</span>. For simplicity we assume that <span class="math inline">\(\Delta x = \Delta y\)</span> so that we can combine like terms from the <span class="math inline">\(x\)</span> derivative and the <span class="math inline">\(y\)</span> derivative. Fill in the missing coefficients and indices below. <span class="math display">\[
U_{i+1,j} + U_{i,j-1} - (\underline{\hspace{0.2in}}) U_{\underline{\hspace{0.2in}},\underline{\hspace{0.2in}}} + U_{\underline{\hspace{0.2in}},\underline{\hspace{0.2in}}} + U_{\underline{\hspace{0.2in}},\underline{\hspace{0.2in}}} = \Delta x^2 f(x_i,y_i)
\]</span></p></li>
<li><p>In <a href="#fig-6.14" class="quarto-xref">Figure&nbsp;<span>9.7</span></a> we see that there are 16 total equations resulting from the discretization of the Poisson equation. Your first task is to write all 16 of these equations. we will get you started: <span class="math display">\[
\begin{aligned} \text{$k=0$: } &amp;\quad U_{k=1} + {\color{red} U_{i=1,j=0} } - 4U_{k=0} + {\color{red} U_{i=0,j=1} } + U_{k=4} = \Delta x^2 f(x_1,y_1) \\ \text{$k=1$: } &amp;\quad U_{k=2} + U_{k=0} - 4U_{k=1} + {\color{red} U_{i=0,j=2} } + U_{k=5} = \Delta x^2 f(x_1,y_2) \\ &amp; \qquad \vdots \\ \text{$k=15$: } &amp;\quad {\color{red} U_{i=4,j=5}} + U_{k=14} - 4 U_{k=15} + U_{k=11} + {\color{red} U_{i=5,j=4}} = \Delta x^2 f(x_4,y_4) \end{aligned}
\]</span> In this particular example we have homogeneous Dirichlet boundary conditions so all of the boundary values are zero. If this was not the case then every boundary value would need to be moved to the right-hand sides of the equations.</p></li>
<li><p>We now have a <span class="math inline">\(16 \times 16\)</span> matrix equation to write based on the equations from part (b). Each row and column of the matrix equation is indexed by <span class="math inline">\(k\)</span>. The coefficient matrix <span class="math inline">\(A\)</span> is started for you below. Write the whole thing out and fill in the blanks. Notice that this matrix has a much more complicated structure than the coefficient matrix in the 1D Poisson and Laplace equations. <span class="math display">\[
A = \begin{pmatrix} -4 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ 1 &amp; -4 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; 1 &amp; -4 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; -4 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; &amp; \\ 1 &amp; 0 &amp; 0 &amp; 0 &amp; -4 &amp; 1 &amp; 0 &amp; 0 &amp; \ddots &amp; \\ 0 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\ \vdots &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\ &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\ &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; -4 \\ \end{pmatrix}
\]</span></p></li>
<li><p>In the coefficient matrix from part (c) notice that the small matrix <span class="math display">\[
\begin{pmatrix} -4 &amp; 1 &amp; 0 &amp; 0 \\ 1 &amp; -4 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; -4 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; -4 \end{pmatrix}
\]</span> shows up in blocks along the main diagonal. If you have a hard copy of the matrix go back and draw a box around these blocks in the coefficient matrix. Also notice that there are diagonal bands of <span class="math inline">\(1^s\)</span>. Discuss the following:</p></li>
</ol>
<ol type="1">
<li><p>Why are the blocks <span class="math inline">\(4 \times 4\)</span>?</p></li>
<li><p>How could you have predicted the location of the diagonal bands of <span class="math inline">\(1^s\)</span>?</p></li>
<li><p>What would the structure of the matrix look like if we partitioned the domain into a <span class="math inline">\(10 \times 10\)</span> grid of points instead of a <span class="math inline">\(6 \times 6\)</span> grid (including the boundary points)?</p></li>
<li><p>Why is it helpful to notice this structure?</p></li>
</ol>
<ol start="5" type="a">
<li><p>The right-hand side of the matrix equation resulting the your system of equations from part (b) is <span class="math display">\[
\boldsymbol{b} = \Delta x^2 \begin{pmatrix} f(x_1,y_1) \\ f(x_1,y_2) \\ f(x_1,y_3) \\ f(x_1,y_4) \\ f(x_2,y_1) \\ f(x_2,y_2) \\ \vdots \\ \\ f(x_4,y_y) \end{pmatrix}.
\]</span> Notice the structure of this vector. Why is it structured this way? Why is it useful to notice this?</p></li>
<li><p>Write Python code to solve the problem at hand. Recall that <span class="math inline">\(f(x,y) = -20\exp\left(-\frac{-(x-0.5)^2+(y-0.5)^2}{0.05}\right)\)</span>. Show a contour plot of your solution. This will take a little work changing the indices back from <span class="math inline">\(k\)</span> to <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>. Think carefully about how you want to code this before you put fingers to keyboard. You might want to use the <code>np.block()</code> command to build the coefficient matrix efficiently or you can use loops with carefully chosen indices.</p></li>
<li><p>(Challenge) Generalize your code to solve the Poisson equation with a much smaller value of <span class="math inline">\(\Delta x = \Delta y\)</span>.</p></li>
<li><p>One more significant observation should be made about the 2D Poisson equation on this square domain. Notice that the corner points of the domain (e.g.&nbsp;<span class="math inline">\(i=0, j=0\)</span> or <span class="math inline">\(i=5, j=0\)</span>) are never included in the system of equations. What does this mean about trying to enforce boundary conditions that only apply at the corners?</p></li>
</ol>
<div id="fig-6.14" class="quarto-float quarto-figure quarto-figure-left anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-6.14-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/PDE/2DPoisson.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-6.14-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9.7: A finite difference grid for the Poisson equation with 6 grid points in each direction.
</figcaption>
</figure>
</div>
</div>
<hr>
</section>
<section id="algorithm-summaries" class="level2" data-number="9.6">
<h2 data-number="9.6" class="anchored" data-anchor-id="algorithm-summaries"><span class="header-section-number">9.6</span> Algorithm Summaries</h2>
<div id="exr-6.76" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.48</strong></span> Show the full mathematical details for building a first-order in time and second-order in space approximation method for the one-dimensional heat equation. Explain what the order of the error means in this context</p>
</div>
<hr>
<div id="exr-6.77" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.49</strong></span> Show the full mathematical details for building a second-order in time and second-order in space approximation method for the one-dimensional wave equation. Explain what the order of the error means in this context</p>
</div>
<hr>
<div id="exr-6.78" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.50</strong></span> Show the full mathematical details for building a first-order in time and second-order in space approximation method for the two-dimensional heat equation. Explain what the order of the error means in this context</p>
</div>
<hr>
<div id="exr-6.79" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.51</strong></span> Show the full mathematical details for building a second-order in time and second-order in space approximation method for the two-dimensional wave equation. Explain what the order of the error means in this context</p>
</div>
<hr>
<div id="exr-6.80" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.52</strong></span> Explain in clear language what it means for a finite difference method to be stable versus unstable.</p>
</div>
<hr>
<div id="exr-6.81" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.53</strong></span> Show the full mathematical details for solving the 1D heat equation using the implicit and Crank-Nicolson methods.</p>
</div>
<hr>
<div id="exr-6.82" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.54</strong></span> Show the full mathematical details for building a downwind finite difference scheme for the travelling wave equation. Discuss the primary disadvantages of the downwind scheme.</p>
</div>
<hr>
<div id="exr-6.83" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.55</strong></span> Show the full mathematical details for building an upwind finite difference scheme for the travelling wave equation. Discuss the primary disadvantages of the upwind scheme.</p>
</div>
<hr>
<div id="exr-6.84" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.56</strong></span> Show the full mathematical details for numerically solving the 1D Laplace and Poisson equations.</p>
</div>
<hr>
</section>
<section id="problems" class="level2" data-number="9.7">
<h2 data-number="9.7" class="anchored" data-anchor-id="problems"><span class="header-section-number">9.7</span> Problems</h2>
<div id="exr-6.85" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.57</strong></span> In this problem we will solve a more realistic 1D heat equation. We will allow the diffusivity to change spatially, so <span class="math inline">\(D = D(x)\)</span> and we want to solve <span class="math display">\[
u_t = \left( D(x) u_x \right)_x
\]</span> on <span class="math inline">\(x \in (0,1)\)</span> with Dirichlet boundary conditions <span class="math inline">\(u(t,0) = u(t,1) = 0\)</span> and initial condition <span class="math inline">\(u(0,x) = \sin(2 \pi x)\)</span>. This is “more realistic” since it would be rare to have a perfectly homogeneous medium, and the function <span class="math inline">\(D\)</span> reflects any heterogeneities in the way the diffusion occurs. In this problem we will take <span class="math inline">\(D(x)\)</span> to be the parabola <span class="math inline">\(D(x)= x^3(1-x)\)</span>. We start by doing some calculus to rewrite the differential equation: <span class="math display">\[
u_t = D(x) u_{xx}(x) + D'(x) u_x(x).
\]</span></p>
<p>Your jobs are:</p>
<ol type="1">
<li><p>Describe what this choice of <span class="math inline">\(D(x)\)</span> might mean physically in the heat equation.</p></li>
<li><p>Write an explicit scheme to solve this problem by using centred differences for the spatial derivatives and an Euler-type discretization for the temporal derivative. Write a clear and thorough explanation for how you are doing the discretization as well as a discussion for the errors that are being made with each discretization.</p></li>
<li><p>Write a script to find an approximate solution to this problem.</p></li>
<li><p>Write a clear and thorough discussion about how your will choose <span class="math inline">\(\Delta x\)</span> and <span class="math inline">\(\Delta t\)</span> to give stable solutions to this equation.</p></li>
<li><p>Graphically compare your solution to this problem with a heat equation where <span class="math inline">\(D\)</span> is taken to be the constant average diffusivity found by calculating <span class="math inline">\(D_{ave} = \int_0^1 D(x) dx.\)</span> How does the changing diffusivity change the shape of the solution?</p></li>
</ol>
</div>
<hr>
<div id="exr-6.86" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.58</strong></span> In a square domain create a function <span class="math inline">\(u(0,x,y)\)</span> that looks like the university logo. The simplest way to do this might be to take a photo of the logo, crop it to a square, and use the <code>scipy.ndimage.imread</code> command to read in the image. Use this function as the initial condition for the heat equation on a square domain with homogeneous Dirichlet boundary conditions. Numerically solve the heat equation and show an animation for what happens to the logo as time evolves.</p>
</div>
<hr>
<div id="exr-6.87" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.59</strong></span> Repeat the previous exercise but this time solve the wave equation with the logo as the initial condition.</p>
</div>
<hr>
<div id="exr-6.88" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.60</strong></span> The explicit finite difference scheme that we built for the 1D heat equation in this chapter has error on the order of <span class="math inline">\(\mathcal{O}(\Delta t) + \mathcal{O}(\Delta x^2)\)</span>. Explain clearly what this means. Then devise a numerical experiment to empirically test this fact. Clearly explain your thought process and show sufficient plots and mathematics to support your work.</p>
</div>
<hr>
<div id="exr-6.89" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.61</strong></span> Suppose that we have a concrete slab that is 10 meters in length, with the left boundary held at a temperature of <span class="math inline">\(75^\circ\)</span> and the right boundary held at a temperature of <span class="math inline">\(90^\circ\)</span>. Assume that the thermal diffusivity of concrete is about <span class="math inline">\(k = 10^{-5}\)</span> m<span class="math inline">\(^2\)</span>/s. Assume that the initial temperature of the slab is given by the function <span class="math inline">\(T(x) = 75 + 1.5x - 20 \sin( \pi x / 10)\)</span>. In this case, the temperature can be analytically solved by the function <span class="math inline">\(T(t,x) = 75 + 1.5x - 20 \sin(\pi x / 10) e^{-ct}\)</span> for some value of <span class="math inline">\(c\)</span>.</p>
<ol type="1">
<li><p>Working by hand (no computers!) test the proposed analytic solution by substituting it into the 1D heat equation and verifying that it is indeed a solution. In doing so you will be able to find the correct value of <span class="math inline">\(c\)</span>.</p></li>
<li><p>Write numerical code to solve this 1D heat equation. The output of your code should be an animation showing how the error between the numerical solution and the analytic solution evolve in time.</p></li>
</ol>
</div>
<hr>
<div id="exr-6.90" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.62</strong></span> (This problem is modified from <span class="citation" data-cites="Spayd">(<a href="#ref-Spayd" role="doc-biblioref">Kimberly Spayd and James Puckett 2022</a>)</span>). The data given below is real experimental data provided courtesy of the authors.)</p>
<p>Harry and Sally set up an experiment to gather data specifically for the heat diffusion through a long thin metal rod. Their experimental setup was as follows.</p>
<ul>
<li><p>The ends of the rod are submerged in water baths at different temperatures and the heat from the hot water bath (on the right hand side) travels through the metal to the cooler end (on the left hand side).</p></li>
<li><p>The temperature of the rod is measured at four locations; those measurements are sent to a Raspberry Pi, which processes the raw data and sends the collated data to be displayed on the computer screen.</p></li>
<li><p>They used a metal rod of length <span class="math inline">\(L = 300 mm\)</span> and square cross-sectional width <span class="math inline">\(3.2 mm\)</span>.</p></li>
<li><p>The temperature sensors were placed at <span class="math inline">\(x_1 = 47mm\)</span>, <span class="math inline">\(x_2 = 94mm\)</span>, <span class="math inline">\(x_3 = 141mm\)</span>, and <span class="math inline">\(x_4 = 188mm\)</span> as measured from the cool end (the left end).</p></li>
<li><p>Foam tubing, with a thickness of 25 mm, was wrapped around the rod and sensors to provide some insulation.</p></li>
<li><p>The ambient temperature in the room was <span class="math inline">\(22^\circ C\)</span> and the cool water bath is a large enough reservoir that the left side of the rod is kept at <span class="math inline">\(22^\circ C\)</span>.</p></li>
</ul>
<p>The data table below gives temperature measurements at 60 second intervals for each of the four sensors.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 19%">
<col style="width: 19%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Time (sec)</strong></th>
<th><strong>Sensor 188</strong></th>
<th><strong>Sensor 141</strong></th>
<th><strong>Sensor 94</strong></th>
<th><strong>Sensor 47</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>22.8</td>
<td>22</td>
<td>22</td>
<td>22</td>
</tr>
<tr class="even">
<td>60</td>
<td>29.3</td>
<td>24.4</td>
<td>23.2</td>
<td>22.8</td>
</tr>
<tr class="odd">
<td>120</td>
<td>35.7</td>
<td>27.5</td>
<td>25.9</td>
<td>25.2</td>
</tr>
<tr class="even">
<td>180</td>
<td>41.8</td>
<td>30.3</td>
<td>27.9</td>
<td>26.8</td>
</tr>
<tr class="odd">
<td>240</td>
<td>45.8</td>
<td>33.8</td>
<td>30.6</td>
<td>29.2</td>
</tr>
<tr class="even">
<td>300</td>
<td>48.2</td>
<td>36.5</td>
<td>32.6</td>
<td>31.2</td>
</tr>
<tr class="odd">
<td>360</td>
<td>50.6</td>
<td>37.7</td>
<td>34.2</td>
<td>32</td>
</tr>
<tr class="even">
<td>420</td>
<td>53.4</td>
<td>38.5</td>
<td>34.9</td>
<td>32.8</td>
</tr>
<tr class="odd">
<td>480</td>
<td>53</td>
<td>38.9</td>
<td>35.3</td>
<td>33.6</td>
</tr>
<tr class="even">
<td>540</td>
<td>53</td>
<td>40.4</td>
<td>36.5</td>
<td>34.8</td>
</tr>
<tr class="odd">
<td>600</td>
<td>55.1</td>
<td>41.2</td>
<td>37.3</td>
<td>35.2</td>
</tr>
<tr class="even">
<td>660</td>
<td>54.7</td>
<td>42</td>
<td>38.1</td>
<td>35.6</td>
</tr>
<tr class="odd">
<td>720</td>
<td>54.7</td>
<td>42.4</td>
<td>38.1</td>
<td>36</td>
</tr>
<tr class="even">
<td>780</td>
<td>54.7</td>
<td>42.4</td>
<td>38.1</td>
<td>36.4</td>
</tr>
<tr class="odd">
<td>840</td>
<td>54.7</td>
<td>42</td>
<td>38.5</td>
<td>36</td>
</tr>
<tr class="even">
<td>900</td>
<td>57.5</td>
<td>41.2</td>
<td>37.7</td>
<td>35.6</td>
</tr>
<tr class="odd">
<td>960</td>
<td>56.3</td>
<td>40.8</td>
<td>37.3</td>
<td>35.6</td>
</tr>
</tbody>
</table>
<ol type="1">
<li><p>At time time <span class="math inline">\(t=960\)</span> seconds the temperatures of the rod are essentially at a steady state. Use this data to make a prediction of the temperature of the hot water bath located at <span class="math inline">\(x=300mm\)</span>.</p></li>
<li><p>The thermal diffusivity, <span class="math inline">\(D\)</span>, of the metal is unknown. Use your numerical solution in conjunction with the data to approximate the value of <span class="math inline">\(D\)</span>. Be sure to fully defend your process.</p></li>
<li><p>It is unlikely that your numerical solution to the heat equation and the data from part 2 match very well. What are some sources of error in the data or in the heat equation model?</p></li>
</ol>
<p>You can load the data directly with the following code.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>URL <span class="op">=</span> <span class="st">'https://github.com/gustavdelius/NumericalAnalysis2025/raw/main/data/PDE/'</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.array(pd.read_csv(URL<span class="op">+</span><span class="st">'1dheatdata.csv'</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<div id="exr-6.91" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.63</strong></span> You may recall from your differential equations class that population growth under limited resources is governed by the logistic equation <span class="math inline">\(x' = k_1x(1-x/k_2)\)</span> where <span class="math inline">\(x=x(t)\)</span> is the population, <span class="math inline">\(k_1\)</span> is the intrinsic growth rate of the population, and <span class="math inline">\(k_2\)</span> is the carrying capacity of the population. The carrying capacity is the maximum population that can be supported by the environment. The trouble with this model is that the species is presumed to be fixed to a spatial location. Let us make a modification to this model that allows the species to spread out over time while they reproduce. We have seen throughout this chapter that the heat equation <span class="math inline">\(u_t = D(u_{xx} + u_{yy})\)</span> models the diffusion of a substance (like heat or concentration). We therefore propose the model<br>
</p>
<p><span class="math display">\[
\frac{\partial u}{\partial t} = k_1 u \left( 1 - \frac{u}{k_2} \right) + D \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} \right)
\]</span> where <span class="math inline">\(u(t,x,y)\)</span> is the population density of the species at time <span class="math inline">\(t\)</span> and spatial point <span class="math inline">\((x,y)\)</span>, <span class="math inline">\((x,y)\)</span> is a point in some square spatial domain, <span class="math inline">\(k_1\)</span> is the growth rate of the population, <span class="math inline">\(k_2\)</span> is the carrying capacity of the population, and <span class="math inline">\(D\)</span> is the rate of diffusion. Develop a finite difference scheme to solve this PDE. Experiment with this model showing the interplay between the parameters <span class="math inline">\(D\)</span>, <span class="math inline">\(k_1\)</span>, and <span class="math inline">\(k_2\)</span>. Take an initial condition of <span class="math display">\[
u(0,x,y) = e^{-( (x-0.5)^2 + (y-0.5)^2)/0.05}.
\]</span></p>
</div>
<hr>
<div id="exr-6.92" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.64</strong></span> In <a href="#exr-6.72" class="quarto-xref">Exercise&nbsp;<span>9.47</span></a> you solved the Poisson equation, <span class="math inline">\(u_{xx} + u_{yy} = f(x,y)\)</span>, on the unit square with homogeneous Dirichlet boundary conditions and a forcing function <span class="math inline">\(f(x,y) = -20 \exp\left(-\frac{(x-0.5)^2 + (y-0.5)^2}{0.05} \right)\)</span>. Use a <span class="math inline">\(10 \times 10\)</span> grid of points to solve the Poisson equation on the same domain with the same forcing function but with boundary conditions <span class="math display">\[
u(0,y)=0, \quad u(1,y) = 0, \quad u(x,0) = -\sin(\pi x), \quad u(x,1) = 0.
\]</span> Show a contour plot of your solution.</p>
</div>
</section>
<section id="projects" class="level2" data-number="9.8">
<h2 data-number="9.8" class="anchored" data-anchor-id="projects"><span class="header-section-number">9.8</span> Projects</h2>
<p>In this section we propose several ideas for projects related to numerical partial differential equations. These projects are meant to be open ended, to encourage creative mathematics, to push your coding skills, and to require you to write and communicate your mathematics.</p>
<section id="hunting-and-diffusion" class="level3" data-number="9.8.1">
<h3 data-number="9.8.1" class="anchored" data-anchor-id="hunting-and-diffusion"><span class="header-section-number">9.8.1</span> Hunting and Diffusion</h3>
<p>Let <span class="math inline">\(u\)</span> be a function modelling a mobile population in an environment where it has an intrinsic growth rate of <span class="math inline">\(r\)</span> and a carrying capacity of <span class="math inline">\(K\)</span>. If we were only worried about the size of the population we could solve the differential equation <span class="math display">\[
\frac{du}{dt} = ru \left( 1-\frac{u}{K} \right),
\]</span> but there is more to the story.</p>
<p>Hunters harvest the population at a per-capita rate <span class="math inline">\(h\)</span> so we can append the differential equation with the harvesting term <span class="math inline">\(-h u\)</span> to arrive at the ordinary differential equation <span class="math display">\[
\frac{du}{dt} = ru \left( 1-\frac{u}{K} \right) - hu.
\]</span></p>
<p>Since the population is mobile let us make a few assumptions about the environment that they are in and how the individuals move.</p>
<ul>
<li><p>The growing conditions for the population are the same everywhere</p></li>
<li><p>Individuals move around randomly.</p></li>
</ul>
<p>Clearly these assumptions imply that our model is a simplification of real populations and real environments, but let us go with it for now. Given the nature of these assumptions we assume that a diffusion term models the spread of the individuals in the population. Hence, the PDE model is <span class="math display">\[
\frac{\partial u}{\partial t} = ru\left( 1-\frac{u}{K} \right) - hu + D \left( u_{xx} + u_{yy} \right).
\]</span></p>
<ol type="1">
<li><p>Use any of your ODE codes to solve the ordinary differential equation with harvesting. Give a complete description of the parameter space.</p></li>
<li><p>Write code to solve the spatial+temporal PDE equation on the 2D domain <span class="math inline">\((x,y) \in [0,1] \times [0,1]\)</span>. Choose an appropriate initial condition and choose appropriate boundary conditions.</p></li>
<li><p>The third assumption is not necessary true for rough terrain. The true form of the spatial component of the differential equation is <span class="math inline">\(\nabla \cdot \left( D(x,y) \nabla u \right)\)</span> where <span class="math inline">\(D(x,y)\)</span> is a multivariable function dictating the ease of diffusion in different spatial locations. Propose a (non-negative) function <span class="math inline">\(D(x,y)\)</span> and repeat part 2 with this new diffusion term.</p></li>
</ol>
</section>
<section id="heating-adobe-houses" class="level3" data-number="9.8.2">
<h3 data-number="9.8.2" class="anchored" data-anchor-id="heating-adobe-houses"><span class="header-section-number">9.8.2</span> Heating Adobe Houses</h3>
<p>Adobe houses, typically built in desert climates, are known for their great thermal efficiency. The heat equation <span class="math display">\[
\frac{\partial T}{\partial t} = \frac{k}{c_p \rho} \left( T_{xx} + T_{yy} + T_{zz} \right),
\]</span> where <span class="math inline">\(c_p\)</span> is the specific heat of the adobe, <span class="math inline">\(\rho\)</span> is the mass density of the adobe, and <span class="math inline">\(k\)</span> is the thermal conductivity of the adobe, can be used to model the heat transfer through the adobe from the outside of the house to the inside. Clearly, the thicker the adobe walls the better, but there is a trade off to be considered:</p>
<ul>
<li><p>it would be prohibitively expensive to build walls so think that the inside temperature was (nearly) constant, and</p></li>
<li><p>if the walls are too thin then the cost is low but the temperature inside has a large amount of variability.</p></li>
</ul>
<p>Your Tasks:</p>
<ol type="1">
<li><p>Pick a desert location in the southwestern US (New Mexico, Arizona, Nevada, or Southern California) and find some basic temperature data to model the outside temperature during typical summer and winter months.</p></li>
<li><p>Do some research on the cost of building adobe walls and find approximations for the parameters in the heat equation.</p></li>
<li><p>Use a numerical model to find the optimal thickness of an adobe wall. Be sure to fully describe your criteria for optimality, the initial and boundary conditions used, and any other simplifying assumptions needed for your model.</p></li>
</ol>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Spayd" class="csl-entry" role="listitem">
Kimberly Spayd, and James Puckett. 2022. <span>“9-020-HeatDiffusion-ModelingScenario.”</span> <a href="https://doi.org/doi:/10.25334/WFSN-Q683">https://doi.org/doi:/10.25334/WFSN-Q683</a>.
</div>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./nmODE.html" class="pagination-link" aria-label="Ordinary Differential Equations">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Ordinary Differential Equations</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/gustavdelius/NumericalAnalysis2025/edit/main/nmPDE.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></div></div></footer></body></html>