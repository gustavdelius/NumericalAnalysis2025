[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Numerical Analysis 2025",
    "section": "",
    "text": "Introduction\nMathematics is not just an abstract pursuit; it is an essential tool that powers a vast array of applications. From weather forecasting to black hole simulations, from urban planning to medical research, the application of mathematics has become indispensable. Central to this applied force is Numerical Analysis.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#what-is-numerical-analysis",
    "href": "index.html#what-is-numerical-analysis",
    "title": "Numerical Analysis 2025",
    "section": "What Is Numerical Analysis?",
    "text": "What Is Numerical Analysis?\nNumerical Analysis is the discipline that bridges continuous mathematical theories with their concrete implementation on digital computers. These computers, by design, work with discrete quantities, and translating continuous problems into this discrete realm is not always straightforward.\nIn this module, we will explore some key techniques, algorithms, and principles of Numerical Analysis that enable us to translate mathematical problems into computational solutions. We will delve into the challenges that arise in this translation, the strategies to overcome them, and the interaction of theory and practice.\nMany mathematical problems cannot be solved analytically in closed form. In Numerical Analysis, we aim to find approximation algorithms for mathematical problems, i.e., schemes that allow us to compute the solution approximately. These algorithms use only elementary operations (\\(+,-,\\times,/\\)) but often a long sequence of them, so that in practice they need to be run on computers.\n\nExample from Algebra\nSolve the equation \\(\\log(x) = \\sin(x)\\) for \\(x\\) in the interval \\(x \\in (0,\\pi)\\). Stop and try using all of the algebra that you ever learned to find \\(x\\). You will quickly realize that there are no by-hand techniques that can solve this problem! A numerical approximation, however, is not so hard to come by. The following graph shows that there is a solution to this equation somewhere between \\(2\\) and \\(2.5\\).\n\n\nCode\n# plot the function cos(x) and the line y=x\nimport matplotlib.pyplot as plt\nimport numpy as np\nx = np.linspace(1, 4, 100)\nplt.plot(x, np.log(x), label=\"log(x)\")\nplt.plot(x, np.sin(x), label=\"sin(x)\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nFigure¬†1: The functions \\(\\log(x)\\) and \\(\\sin(x)\\) intersect at exactly one point, giving the solution to the equation \\(\\log(x) = \\sin(x)\\).\n\n\n\n\n\n\n\nExample from Calculus\nWhat if we want to evaluate\n\\[\n    \\int_0^\\pi \\sin(x^2) dx?\n\\]\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef f(x):\n    return np.sin(x**2)\n\na = 0\nb = np.pi\nn = 1000  # Number of points for numerical integration\n\nx = np.linspace(a, b, n)\ny = f(x)\n\n# Calculate the numerical integral using the trapezoidal rule\nintegral = np.trapz(y, x)\n\n# Shade the positive and negative regions differently\nplt.fill_between(x, y, where=y&gt;=0, color='green', alpha=0.5, label=\"Positive\")\nplt.fill_between(x, y, where=y&lt;0, color='red', alpha=0.5, label=\"Negative\")\n\n# Plot the curve\nplt.plot(x, y, color='black', label=r\"sin(x^2)\")\n\n# Set labels and title\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.title(\"Integral of sin(x^2) from 0 to pi\")\n\n# Add legend\nplt.legend()\n\n# Show the plot\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure¬†2: Visual representation of the integral of \\(\\sin(x^2)\\) from \\(0\\) to \\(\\pi\\).\n\n\n\n\n\nAgain, trying to use any of the possible techniques for using the Fundamental Theorem of Calculus, and hence finding an antiderivative, on the function \\(\\sin(x^2)\\) is completely hopeless. Substitution, integration by parts, and all of the other techniques that you know will all fail. Again, a numerical approximation is not so difficult and is very fast and gives the value\n\n\nCode\n# Use Simpson's rule to approximate the integral of sin(x^2) from 0 to pi\nfrom scipy.integrate import simpson\nsimpson(y, x = x)\n\n\n0.7726517138019184\n\n\nBy the way, this integral (called the Fresnel Sine Integral) actually shows up naturally in the field of optics and electromagnetism, so it is not just some arbitrary integral that was cooked up just for fun.\n\n\nExample from Differential Equations\nSay we needed to solve the differential equation\n\\[\\frac{dy}{dt} = \\sin(y^2) + t.\\]\nThe nonlinear nature of the problem precludes us from using most of the typical techniques (e.g.¬†separation of variables, undetermined coefficients, Laplace Transforms, etc). However, computational methods that result in a plot of an approximate solution can be made very quickly. Here is a plot of the solution up to time \\(t=2.5\\) with initial condition \\(y(0)=0.1\\):\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef f(t, y):\n    return np.sin(y**2) + t\n\n# Initial condition\ny0 = 0.1\n\n# Time span for the solution\nt_span = (0, 2.5)\n\n# Solve the differential equation using SciPy's solver\nsol = solve_ivp(f, t_span, [y0], max_step=0.1, dense_output=True)\n\n# Extract the time values and solution\nt = sol.t\ny = sol.sol(t)[0]  \n\n# Plot the numerical solution\nplt.plot(t, y)\n\n# Labels and title\nplt.xlabel('t')\nplt.ylabel('y')\n\n# Show the plot\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure¬†3: Plot of numerical solution of \\(dy/dt=\\sin(y^2)+t\\) with \\(y(0)=0.1\\).\n\n\n\n\n\nThis was an artificial example, but differential equations are central to modelling the real world in order to predict the future. They are the closest thing we have to a crystal ball. Here is a plot of a numerical solution of the SIR model of the evolution of an epidemic over time:\n\n\nCode\nimport numpy as np\nfrom scipy.integrate import odeint\nimport matplotlib.pyplot as plt\n\n# SIR model differential equations\ndef sir_model(y, t, N, beta, gamma):\n    S, I, R = y\n    dSdt = -beta * S * I / N\n    dIdt = beta * S * I / N - gamma * I\n    dRdt = gamma * I\n    return dSdt, dIdt, dRdt\n\n# Total population, N\nN = 1000\n# Initial number of infected and recovered individuals\nI0, R0 = 1, 0\n# Everyone else is susceptible to infection initially\nS0 = N - I0 - R0\n# Contact rate, beta, and mean recovery rate, gamma, (in 1/days)\nbeta, gamma = 0.25, 1./20 \n# A grid of time points (in days)\nt = np.linspace(0, 160, 160)\n\n# Initial conditions vector\ny0 = S0, I0, R0\n# Integrate the SIR equations over the time grid, t\nret = odeint(sir_model, y0, t, args=(N, beta, gamma))\nS, I, R = ret.T\n\n# Plot the data on three separate curves for S(t), I(t) and R(t)\nplt.figure(figsize=(10,6))\nplt.plot(t, S, 'b', alpha=0.7, linewidth=2, label='Susceptible')\nplt.plot(t, I, 'y', alpha=0.7, linewidth=2, label='Infected')\nplt.plot(t, R, 'g', alpha=0.7, linewidth=2, label='Recovered')\nplt.xlabel('Time /days')\nplt.ylabel('Number (1000s)')\nplt.ylim(0, N)\nplt.title('SIR Model Simulation')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nFigure¬†4: Plot of a numerical solution of the SIR model\n\n\n\n\n\n\n\nReasons to study Numerical Analysis\nSo why should you want to venture into Numerical Analysis rather than just use the computer as a black box?\n\nPrecision and Stability: Computers, despite their power, can introduce significant errors if mathematical problems are implemented without care. Numerical Analysis offers techniques to ensure we obtain results that are both accurate and stable.\nEfficiency: Real-world applications often demand not just correctness, but efficiency. By grasping the methods of Numerical Analysis, we can design algorithms that are both accurate and resource-efficient.\nBroad Applications: Whether your interest lies in physics, engineering, biology, finance, or many other scientific fields, Numerical Analysis provides the computational tools to tackle complex problems in these areas.\nBasis for Modern Technologies: Core principles of Numerical Analysis are foundational in emerging fields such as artificial intelligence, quantum computing, and data science.\n\nThe prerequisites for this material include a firm understanding of calculus and linear algebra and a good understanding of the basics of differential equations.\nBy the end of this module, you will not merely understand the methods of Numerical Analysis; you will be equipped to apply them efficiently and effectively in diverse scenarios: you will be able to tackle problems in physics, engineering, biology, finance, and many other fields; you will be able to design algorithms that are both accurate and resource-efficient; you will be able to ensure that your computational solutions are both accurate and stable; you will be able to leverage the power of computers to solve complex problems.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#the-inquiry-based-approach",
    "href": "index.html#the-inquiry-based-approach",
    "title": "Numerical Analysis 2025",
    "section": "The Inquiry-Based Approach",
    "text": "The Inquiry-Based Approach\nThis material is written with an Inquiry-Based Learning (IBL) flavor. In that sense, these notes are not a traditional textbook containing all of the expected theorems, proofs, code, examples, and exposition. You are encouraged to work through exercises, problems and projects, present your findings, and work together when appropriate.\nIn our first session we will start off right away with an exercise designed for groups, discussion, disagreement, and deep critical thinking. This exercise is inspired by Dana Ernst‚Äôs first day IBL activity titled: Setting the Stage.\n\n\nExercise 1 ¬†\n\nGet in groups of size 3 or 4.\nIntroduce yourself to each other.\nFor each of the questions that follow I will ask you to:\n\n\nThink about a possible answer on your own\nDiscuss your answers with the rest of the group\nShare a summary of each group‚Äôs discussion\n\nQuestions:\nQuestion 1: What are the goals of a university education?\nQuestion 2: How does a person learn something new?\nQuestion 3: What do you reasonably expect to remember from your courses in 20 years?\nQuestion 4: What is the value of making mistakes in the learning process?\nQuestion 5: How do we create a safe environment where risk taking is encouraged and productive failure is valued?",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#how-this-module-works",
    "href": "index.html#how-this-module-works",
    "title": "Numerical Analysis 2025",
    "section": "How this module works",
    "text": "How this module works\nThere are 4 one-hour whole-class sessions every week. Three of these are listed on your timetable as ‚ÄúLecture‚Äù and one as ‚ÄúComputer Practical‚Äù. However, in all these sessions you, the student, are the one that is doing the work; discovering methods, writing code, working problems, leading discussions, and pushing the pace. I, the lecturer, will act as a guide who only steps in to redirect conversations or to provide necessary insight. You will use the whole-class sessions to share and discuss your work with the other members of your group. There will also be some whole-class discussions moderated by your lecturer.\nYou will find that this text is not a set of lecture notes. Instead it mostly just contains collections of exercises with minimal interweaving exposition. It is expected that you do every one of the exercises in the main body of each chapter and use the sequencing of the exercises to guide your learning and understanding.\nTherefore the whole-class sessions form only a very small part of your work on this module. For each hour of whole-class work you should timetable yourself about two and a half hours of work outside class for working through the exercises on your own. I strongly recommend that you put those two and a half hours (ten hours spread throughout the week) into your timetable.\nIn order to enable you to get immediate feedback on your work also in between class sessions, I have made feedback quizzes where you can test your understanding of the material and your results from some of the exercises. Exercises that have an associated question in the feedback quiz are marked with a üéì.\nAt the end of each chapter there is a section entitled ‚ÄúProblems‚Äù that contains additional exercises aimed at consolidating your new understanding and skills. Of these you should aim to do as many as you can but you will not have time to do them all. As the module progresses I will give advice on which of those problems to attack. There are no traditional problem sheets in this module. In this module you will be working on exercises continuously throughout the week rather than working through a problem sheet only every other week.\nMany of the chapters also have a section entitled ‚ÄúProjects‚Äù. These projects are more open-ended investigations, designed to encourage creative mathematics, to push your coding skills and to require you to write and communicate mathematics. These projects are entirely optional and perhaps you will like to return to one of these even after the module has finished. If you do work on one of the projects, be sure to share your work with your lecturer at gustav.delius@york.ac.uk who will be very interested, also after the end of the module.\nIf you notice any mistakes or unclear things in the learning guide, please let me know. Many thanks go to Ben Mason and Toby Cheshire for the corrections they had sent in last year.\nYou will need two notebooks for working through the exercises in this guide: one in paper form and one electronic. Some of the exercises are pen-and-paper exercises while others are coding exercises and some require both writing or sketching and coding. The two notebooks will be linked through the numbering of the exercises.\nFor the coding notebook I highly recommend using Google Colab (or Jupyter Notebook). This will be discussed more in 1¬† Essential Python that introduces Python. Most students find it easiest to have one dedicated Colab notebook (or Jupyter notebook) per section, but some students will want to have one per chapter. You are highly encouraged to write explanatory text into your Google Colab notebooks as you go so that future-you can tell what it is that you were doing, which problem(s) you were solving, and what your thought processes were.\nIn the end, your collection of notebooks will contain solutions to every exercise in the guide and can serve as a reference manual for future numerical analysis problems. At the end of each of your notebooks you may also want to add a summary of what you have learned, which will both consolidate your learning and make it easier for you to remind yourself of your new skills later.\nOne request: do not share your notebooks publicly on the internet because that would create temptation for future students to not put in the work themselves, thereby robbing them of the learning experience.\nIf you have a notebook computer, bring it along to the class sessions. However this is not a requirement. Your lecturer will bring along some spare machines to make sure that every group has at least one computer to use during every session. The only requirements for a computer to be useful for this module is that it can connect to the campus WiFi, can run a web browser, and has a physical keyboard (typing code on virtual keyboards is too slow). The ‚ÄúComputer Practical‚Äù takes place in a PC classroom, so there will of course be plenty of machines available then.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#assessment",
    "href": "index.html#assessment",
    "title": "Numerical Analysis 2025",
    "section": "Assessment",
    "text": "Assessment\nUnfortunately, your learning in the module also needs to be assessed. The final mark will be made up of 40% coursework and 60% final exam.\nThe 40% coursework mark will come from 10 short quizzes that will take place during the ‚ÄúComputer practical‚Äù in weeks 2 to 11. Answering each quiz should take less than 5 minutes but you will be given 10 minutes to complete it to give you a large safety margin and remove stress. The quizzes will be based on exercises that you will already have worked through and for which you will have had time to discuss them in class, so they will be really easy if you have engaged with the exercises as intended. Each quiz will be worth 5 points. There will be a practice quiz in the computer practical in week 1 and another one at the start of the practical in week 2.\nDuring the assessment quizzes you will be required to work exclusively on a classroom PC rather than your own machine. You will do your work in a Colab notebook in which the AI features have been switched off. You can find more info on the use of Colab notebooks in this module in the Essential Python chapter of the Numerical Analysis Learning Guide.\nWhile working on the quiz on the classroom PC you are only allowed to use a web browser, and the only pages you are allowed to have open are this guide, the quiz page on Moodle and any of your notebooks on Google Colab, with the AI features switched off. You are not allowed to use any AI assistants or other web pages. Besides your online notebooks you may also use any hand-written notes as long as you have written them yourself.\nLate submissions will be accepted until 5 minutes after the deadline but there will be one penalty point deduction for a late submission. Submissions that are more than 5 minutes late will get 0 points.\nTo allow for the fact that there may be weeks in which you are ill or otherwise prevented from performing to your best in the assessment quizzes, your final coursework mark will be calculated as the average over your 8 best marks. If exceptional circumstances affect more than two of the 10 quizzes then you would need to submit an exceptional circumstances claim.\nThere will be a practice assessment quiz in week 1 that will not count for anything.\nThe 60% final exam will be a 2 hour exam of the usual closed-book form in an exam room during the exam period. I will make a practice exam available at the end of the module.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#textbooks",
    "href": "index.html#textbooks",
    "title": "Numerical Analysis 2025",
    "section": "Textbooks",
    "text": "Textbooks\nIn this module we will only scratch the surface of the vast subject that is Numerical Analysis. The aim is for you at the end of this module to be familiar with some key ideas and to have the confidence to engage with new methods when they become relevant to you.\nThere are many textbooks on Numerical Analysis. Standard textbooks are (Burden and Faires 2010) and (Kincaid and Cheney 2009). They contain much of the material from this module. A less structured and more opinionated account can be found in (Acton 1990). Another well known reference that researchers often turn to for solutions to specific tasks is (Press et al. 2007). You will find many others in the library. They may go also under alternative names like ‚ÄúNumerical Methods‚Äù or ‚ÄúScientific Computing‚Äù.\nYou may also want to look at textbooks for specific topics covered in this module, like for example (Butcher 2016) for methods for ordinary differential equations.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#your-jobs",
    "href": "index.html#your-jobs",
    "title": "Numerical Analysis 2025",
    "section": "Your jobs",
    "text": "Your jobs\nYou have the following jobs as a student in this module:\n\nFight! You will have to fight hard to work through this material. The fight is exactly what we are after since it is ultimately what leads to innovative thinking.\nScrew Up! More accurately, do not be afraid to screw up. You should write code, work problems, and develop methods, then be completely unafraid to scrap what you have done and redo it from scratch.\nCollaborate! You should collaborate with your peers, both within your group and across the whole class. Discuss exercises, ask questions, help others.\nEnjoy! Part of the fun of inquiry-based learning is that you get to experience what it is like to think like a true mathematician / scientist. It takes hard work but ultimately this should be fun!\n\n\n¬© Gustav Delius. Some Rights Reserved.\nThis learning guide, adapted from the original text by Eric Sullivan, is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. You may copy, distribute, display, remix, rework, and perform this copyrighted work, as long as you give credit to both Gustav Delius for the adaptations and Eric Sullivan for the original work.\nPlease attribute the original work to Eric Sullivan, formerly Mathematics Faculty at Carroll College, esullivan@carroll.edu, and the adapted work to Gustav Delius, Department of Mathematics, University of York, gustav.delius@york.ac.uk.\nThe original work by Eric Sullivan is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/. The adaptations by Gustav Delius are also published under the same Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\nFor inquiries regarding the use of this learning guide, please contact gustav.delius@york.ac.uk.\n\n\n\n\nActon, Forman S. 1990. Numerical Methods That Work. 1St Edition edition. Washington, D.C: The Mathematical Association of America.\n\n\nBurden, Richard L., and J. Douglas Faires. 2010. Numerical Analysis. 9th ed. Brooks Cole.\n\n\nButcher, J. C. 2016. Numerical Methods for Ordinary Differential Equations. Third edition. Wiley. https://yorsearch.york.ac.uk/permalink/f/1kq3a7l/44YORK_ALMA_DS51336126850001381.\n\n\nKincaid, D. R., and E. W. Cheney. 2009. Numerical Analysis: Mathematics of Scientific Computing. Pure and Applied Undergraduate Texts. American Mathematical Society.\n\n\nPress, William H., Saul A. Teukolsky, William T. Vetterling, and Brian P. Flannery. 2007. Numerical Recipes: The Art of Scientific Computing. Cambridge University Press. https://numerical.recipes/.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "nmPython.html",
    "href": "nmPython.html",
    "title": "1¬† Essential Python",
    "section": "",
    "text": "1.1 Why Python?\nWe are going to be using Python since\nIt is important to keep in mind that Python is a general purpose language that we will be using for Scientific Computing. The purpose of Scientific Computing is not to build apps, build software, manage databases, or develop user interfaces. Instead, Scientific Computing is the use of a computer programming language (like Python) along with mathematics to solve scientific and mathematical problems. For this reason it is definitely not our purpose to write an all-encompassing guide for how to use Python. We will only cover what is necessary for our computing needs. You will learn more as the course progresses so use this chapter just to get going with the language.\nWe are also definitely not saying that Python is the best language for scientific computing under all circumstances. The reason there are so many scientific programming languages coexisting is that each has particular strengths that make it the best option for particular applications. But we are saying that Python is so widely used that every scientist should know Python.\nThere is an overwhelming abundance of information available about Python and the suite of tools that we will frequently use.\nThese tools together provide all of the computational power that we will need. And they are free!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#why-python",
    "href": "nmPython.html#why-python",
    "title": "1¬† Essential Python",
    "section": "",
    "text": "Python is free,\nPython is very widely used,\nPython is flexible,\nPython is relatively easy to learn,\nand Python is quite powerful.\n\n\n\n\n\nPython https://www.python.org/,\nnumpy (numerical Python) https://www.numpy.org/,\nmatplotlib (a suite of plotting tools) https://matplotlib.org/,\nscipy (scientific Python) https://www.scipy.org/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#google-colab",
    "href": "nmPython.html#google-colab",
    "title": "1¬† Essential Python",
    "section": "1.2 Google Colab",
    "text": "1.2 Google Colab\nEvery computer is its own unique flower with its own unique requirements. Hence, we will not spend time here giving you all of the ways that you can install Python and all of the associated packages necessary for this module. Unless you are already familiar with using Python on your own computer, I highly recommend that you use the Google Colab notebook tool for writing your Python code: https://colab.research.google.com.\nGoogle Colab allows you to keep all of your Python code on your Google Drive. The Colab environment is a free and collaborative version of the popular Jupyter notebook project. Jupyter notebooks allow you to write and test code as well as to mix writing (including LaTeX formatting) in along with your code and your output. I recommend that if you are new to Google Colab, you start by watching the brief introductory video.\n\nExercise 1.1 Spend a bit of time poking around in Colab. Figure out how to\n\nCreate new Colab notebooks.\nAdd and delete code cells.\nType a simple calculation like 1+1 into a code cell and evaluate it.\nAdd and delete text cells.\nAdd an equation to a text cell using LaTeX notation.\nSave a notebook to your Google Drive.\nOpen a notebook from Google Drive.\nShare a notebook with other members of your group and see if you can collaboratively edit it.\n\n\n\n\nExercise 1.2 ¬†\n\nClick on this link to a Colab notebook. It should open it in Colab.\nSave a copy of it to your Google Drive. You need a copy because you will not have permission to edit the original.\nFollow the instructions in the notebook.\nShare that notebook with your lecturer gustav.delius@york.ac.uk, giving him at least ‚ÄúCommenter‚Äù privileges.\n\n\n\n\n1.2.1 The use of AI\nYou will have gathered from the previous exercise that in this module you are not only allowed to use AI, you are encouraged to use AI. However you have probably already discovered that you get more out of an AI if you are already familiar with the basic concepts of a subject. You will need to be able to understand and check any answer an AI gives you. If there is something in an AI answer that is not totally clear or not obviously correct, always ask the AI to explain the details of its answer and ask follow-on questions until everything is crystal-clear.\nDuring the 10 assessment quizzes you will not be allowed to use any AI. In particular you will be required to switch off the AI features in Google Colab. It is thus a good idea when working on practice exercises to also switch off the AI features to make sure you know what you are doing even when there is no AI assistance. To switch off the AI features you should tick the ‚ÄúHide generative AI‚Äù checkbox on the ‚ÄúAI assistance‚Äù tab of the ‚ÄúSettings‚Äù page in Google Colab.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#python-programming-basics",
    "href": "nmPython.html#python-programming-basics",
    "title": "1¬† Essential Python",
    "section": "1.3 Python Programming Basics",
    "text": "1.3 Python Programming Basics\nIf you are already very practised in using Python then you can jump straight to Section 1.7 with the coding exercises. But if you are new to Python or your Python skills are a bit rusty, then you will benefit from working through all the examples and exercises below, making sure you copy and paste all the code into your Colab notebook and run it there, and then critically evaluate and understand the output. To copy the code from this guide to your notebook you can use the ‚ÄúCopy to Clipboard‚Äù icon that pops up in the top right corner of a code block in this guide when you hover over that code block.\n\n1.3.1 Variables\nVariable names in Python can contain letters (lower case or capital), numbers 0-9, and some special characters such as the underscore. Variable names must start with a letter. There are a bunch of reserved words that you can not use for your variable names because they have a special meaning in the Python syntax. Python will let you know with a syntax error if you try to use a reserved word for a variable name.\nYou can do the typical things with variables. Assignment is with an equal sign (be careful R users, we will not be using the left-pointing arrow here!).\nWarning: When defining numerical variables you do not always get floating point numbers. In some programming languages, if you write x=1 then automatically x is saved as 1.0; a floating point number, not an integer. In Python however, if you assign x=1 it is defined as an integer (with no decimal digits) but if you assign x=1.0 it is assigned as a floating point number.\n# assign some variables\nx = 7 # integer assignment of the integer 7\ny = 7.0 # floating point assignment of the decimal number 7.0\nprint(\"The variable x has the value\", x, \" and has type\", type(x), \". \\n\")\nprint(\"The variable y has the value\", y, \" and has type\", type(y), \". \\n\")\nRemember to copy each code block to your own notebook, execute it and look at the output.\n# multiplying by a float will convert an integer to a float\nx = 7 # integer assignment of the integer 7\nprint(\"Multiplying x by 1.0 gives\", 1.0*x)\nprint(\"The type of this value is\", type(1.0*x), \". \\n\")\nThe allowed mathematical operations are:\n\nAddition: +\nSubtraction: -\nMultiplication: *\nDivision: /\nInteger Division (modular division): // and %\nExponents: **\n\nThat‚Äôs right, the caret key, ^, is NOT an exponent in Python (sigh). Instead we have to get used to ** for exponents.\nx = 7.0\ny = x**2 # square the value in x\ny\n\n\nExercise 1.3 Write code to define positive integers \\(a,b\\) and \\(c\\) of your own choosing. Then calculate \\(a^2, b^2\\) and \\(c^2\\). When you have all three values computed, check to see if your three values form a Pythagorean Triple so that \\(a^2 + b^2 = c^2\\). Have Python simply say True or False to verify that you do, or do not, have a Pythagorean Triple defined.¬†Hint: You will need to use the == Boolean check just like in other programming languages.\n\n\n\n\n1.3.2 Indexing and Lists\nLists are a key component to storing data in Python. Lists are exactly what the name says: lists of things (in our case, usually the entries are floating point numbers).\nWarning: Python indexing starts at 0 whereas some other programming languages have indexing starting at 1. In other words, the first entry of a list has index 0, the second entry as index 1, and so on. We just have to keep this in mind.\nWe can extract a part of a list using the syntax name[start:stop] which extracts elements between index start and stop-1. Take note that Python stops reading at the second to last index. This often catches people off guard when they first start with Python.\n\n\nExample 1.1 (Lists and Indexing) Let us look at a few examples of indexing from lists. In this example we will use the list of numbers 0 through 8. This list contains 9 numbers indexed from 0 to 8.\n\nCreate the list of numbers 0 through 8\n\nMyList = [0,1,2,3,4,5,6,7,8]\n\nOutput the list\n\nMyList\n\nSelect only the element with index 0.\n\nMyList[0]\n\nSelect all elements up to, but not including, the third element of MyList.\n\nMyList[:2]\n\nSelect the last element of MyList (this is a handy trick!).\n\nMyList[-1] \n\nSelect the elements indexed 1 through 4. Beware! This is not the first through fifth element.\n\nMyList[1:5] \n\nSelect every other element in the list starting with the first.\n\nMyList[0::2]\n\nSelect the last three elements of MyList\n\nMyList[-3:]\n\n\nIn Python, elements in a list do not need to be the same type. You can mix integers, floats, strings, lists, etc.\n\nExample 1.2 In this example we see a list of several items that have different data types: float, integer, string, and complex. Note that the imaginary number \\(i\\) is represented by \\(1j\\) in Python. This is common in many scientific disciplines and is just another thing that we will need to get used to in Python. (For example, \\(j\\) is commonly used as the symbol for the imaginary unit \\(\\sqrt{-1}\\) ) in electrical engineering since \\(i\\) is the symbol commonly used for electric current, and using \\(i\\) for both would be problematic).\nMixedList = [1.0, 7, 'Bob', 1-1j]\nprint(MixedList)\nprint(type(MixedList[0]))\nprint(type(MixedList[1]))\nprint(type(MixedList[2]))\nprint(type(MixedList[3])) \n# Notice that we use 1j for the imaginary number \"i\".\n\n\n\nExercise 1.4 In this exercise you will put your new list skills into practice.\n\nCreate the list of the first several Fibonacci numbers: \\[\\begin{equation}\n1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89.\n\\end{equation}\\]\nPrint the first four elements of the list.\nPrint every third element of the list starting from the first.\nPrint the last element of the list.\nPrint the list in reverse order.\nPrint the list starting at the last element and counting backward by every other element.\n\n\n\n\n\n1.3.3 List Operations\nPython is awesome about allowing you to do things like appending items to lists, removing items from lists, and inserting items into lists. Note in all of the examples below that we are using the code\nvariable.method\nwhere you put the variable name, a dot, and the thing that you would like to do to that variable. For example, MyList.append(7) will append the number 7 to the list MyList. We say that append is a ‚Äúmethod‚Äù of the list MyList. This is a common programming feature in Python and we will use it often.\n\n\nExample 1.3 The .append method can be used to append an element to the end of a list.\nMyList = [0,1,2,3]\nprint(MyList)\n# Append the string 'a' to the end of the list\nMyList.append('a') \nprint(MyList)\n# Do it again ... just for fun\nMyList.append('a') \nprint(MyList)\n# Append the number 15 to the end of the list\nMyList.append(15) \nprint(MyList)\n\n\n\nExample 1.4 The .remove method can be used to remove an element from a list.\n# Let us remove the 3\nMyList.remove(3)\nprint(MyList)\n\n\n\nExample 1.5 The .insert method can be used to insert an element at a location in a list.\n# insert the letter `A` at the 0-indexed spot\nMyList.insert(0,'A') \n# insert the letter `B` at the spot with index 3 \nMyList.insert(3,'B') \n# remember that index 3 means the fourth spot in the list\nprint(MyList)\n\n\n\nExercise 1.5 In this exercise you will go a bit further with your list operation skills.\n\nCreate the list of the first several Lucas Numbers: \\(1,3,4,7,11,18,29,47.\\)\nAdd the next three Lucas Numbers to the end of the list.\nRemove the number 3 from the list.\nInsert the 3 back into the list in the correct spot.\nPrint the list in reverse order.\nDo a few other list operations to this list and report your findings.\n\n\n\n\n\n1.3.4 Tuples\nIn Python, a ‚Äútuple‚Äù is like an ordered pair (or ordered triple, or ordered quadruple, ...) in mathematics. We will occasionally see tuples in our work in numerical analysis so for now let us just give a couple of code snippets showing how to store and read them.\nWe can define the tuple of numbers \\((10,20)\\) in Python as follows:\n\nExample 1.6 ¬†\npoint = 10, 20 \nprint(point, type(point))\nWe can also define a tuple with parenthesis if we like. Python does not care.\npoint = (10, 20) # now we define the tuple with parenthesis\nprint(point, type(point))\nWe can then unpack the tuple into components if we wish:\nx, y = point\nprint(\"x = \", x)\nprint(\"y = \", y)\n\nThere are other important data structures in Python that we will not cover in this module. These include dictionaries and sets. We will not cover these because they are not necessary for our work in numerical analysis. We are trying to keep things simple. If you are interested in learning more about these data structures, you can find a lot of information about them in the Python documentation.\n\n\n1.3.5 Control Flow: Loops and If Statements\nAny time you need to do some repetitive task with a programming language you can use a loop. Just like in other programming languages, we can do loops and conditional statements in very easy ways in Python. The thing to keep in mind is that the Python language is very white-space-dependent. This means that your indentations need to be correct in order for a loop to work. You could get away with sloppy indention in other languages but not so in Python. Also, in some languages (like R and Java) you need to wrap your loops in curly braces. Again, not so in Python.\nCaution: Be really careful of the white space in your code when you write loops.\n\n1.3.5.1 for Loops\nA for loop is designed to do a task a certain number of times and then stop. This is a great tool for automating repetitive tasks, but it also nice numerically for building sequences, summing series, or just checking lots of examples. The following are several examples of Python for loops. Take careful note of the syntax for a for loop as it is the same as for other loops and conditional statements:\n\na control statement,\na colon, a new line,\nindent four spaces,\nsome programming statements\n\nWhen you are done with the loop, just back out of the indention. There is no need for an end command or a curly brace. All of the control statements in Python are white-space-dependent.\n\n\nExample 1.7 Print the first 6 perfect squares.\nfor x in [1,2,3,4,5,6]:\n    print(x**2)\nOften instead of writing the list of integers explicitly one uses the range() function, so that this example would be written as\nfor x in range(1,7):\n    print(x**2)\n\nNote that range(1,7) produces the integers from 1 to 6, not from 1 to 7. This is another manifestation of Python‚Äôs weird 0-based indexing. Of course it is only weird to people who are new to Python. For Pythonists it is perfectly natural.\n\n\nExample 1.8 Print the names in a list.\nNamesList = ['Alice','Billy','Charlie','Dom','Enrique','Francisco']\nfor name in NamesList:\n    print(name)\n\n\nIn Python you can use a more compact notation for for loops sometimes. This takes a bit of getting used to, but is super slick!\n\n\nExample 1.9 Create a list of the perfect squares from 1 to 9.\n# create a list of the perfect squares from 1 to 9\nCoolList = [x**2 for x in range(1,10)]\nprint(CoolList)\n# Then print the sum of this list\nprint(\"The sum of the first 9 perfect squares is\",sum(CoolList))\n\n\nfor loops can also be used to build sequences as can be seen in the next couple of examples.\n\n\nExample 1.10 In the following code we write a for loop that outputs a list of the first 7 iterations of the sequence \\(x_{n+1}=-0.5x_n+1\\) starting with \\(x_0=3\\). Notice that we are using the command x.append instead of \\(x[n+1]\\) to append the new term to the list. This allows us to grow the length of the list dynamically as the loop progresses.\nx=[3.0]\nfor n in range(0,7):\n    x.append(-0.5*x[n] + 1)\n    print(x) # print the whole list x at each step of the loop\n\n\n\nExample 1.11 As an alternative to the code from the previous example we can pre-allocate the memory in an array of zeros. This is done with the clever code x = [0] * 10. Literally multiplying a list by some number, like 10, says to repeat that list 10 times.\nNow we will build the sequence with pre-allocated memory.\nx = [0] * 7\nx[0] = 3.0\nfor n in range(0,6):\n    x[n+1] = -0.5*x[n]+1\n    print(x) # This print statement shows x at each iteration\n\n\n\nExercise 1.6 We want to sum the first 100 perfect cubes. Let us do this in two ways.\n\nStart off a variable called Total at 0 and write a for loop that adds the next perfect cube to the running total.\nWrite a for loop that builds the sequence of the first 100 perfect cubes. After the list has been built find the sum with the sum() function.\n\nThe answer is: 25,502,500 so check your work.\n\n\n\nExercise 1.7 Write a for loop that builds the first 20 terms of the sequence \\(x_{n+1}=1-x_n^2\\) with \\(x_0=0.1\\). Pre-allocate enough memory in your list and then fill it with the terms of the sequence. Only print the list after all of the computations have been completed.\n\n\n\n\n1.3.5.2 while Loops\nA while loop repeats some task (or sequence of tasks) while a logical condition is true. It stops when the logical condition turns from true to false. The structure in Python is the same as with for loops.\n\n\nExample 1.12 Print the numbers 0 through 4 and then the word ‚Äúdone.‚Äù we will do this by starting a counter variable, i, at 0 and increment it every time we pass through the loop.\ni = 0\nwhile i &lt; 5:\n    print(i)\n    i += 1 # increment the counter\nprint(\"done\")\n\n\n\nExample 1.13 Now let us use a while loop to build the sequence of Fibonacci numbers and stop when the newest number in the sequence is greater than 1000. Notice that we want to keep looping until the condition that the last term is greater than 1000 ‚Äì this is the perfect task for a while loop, instead of a for loop, since we do not know how many steps it will take before we start the task\nFib = [1,1]\nwhile Fib[-1] &lt;= 1000:\n    Fib.append(Fib[-1] + Fib[-2])\nprint(\"The last few terms in the list are:\\n\",Fib[-3:])\n\n\n\nExercise 1.8 Write a while loop that sums the terms in the Fibonacci sequence until the sum is larger than 1000\n\n\n\n\n1.3.5.3 if Statements\nConditional (if) statements allow you to run a piece of code only under certain conditions. This is handy when you have different tasks to perform under different conditions.\n\n\nExample 1.14 Let us look at a simple example of an if statement in Python.\nName = \"Alice\"\nif Name == \"Alice\":\n    print(\"Hello, Alice.  Isn't it a lovely day to learn Python?\")\nelse:\n    print(\"You're not Alice.  Where is Alice?\")\nName = \"Billy\"\nif Name == \"Alice\":\n    print(\"Hello, Alice.  Isn't it a lovely day to learn Python?\")\nelse:\n    print(\"You're not Alice.  Where is Alice?\")\n\n\n\nExample 1.15 For another example, if we get a random number between 0 and 1 we could have Python print a different message depending on whether it was above or below 0.5. Run the code below several times and you will see different results each time.\nNote: We have to import the numpy package to get the random number generator in Python. Do not worry about that for now. we will talk about packages in a moment.\nimport numpy as np\nx = np.random.rand(1,1) # get a random 1x1 matrix using numpy\nx = x[0,0] # pull the entry from the first row and first column\nif x &lt; 0.5:\n    print(x,\" is less than a half\")\nelse:\n    print(x, \"is NOT less than a half\")\n(Take note that the output will change every time you run it)\n\n\n\nExample 1.16 In many programming tasks it is handy to have several different choices between tasks instead of just two choices as in the previous examples. This is a job for the elif command.\nThis is the same code as last time except we will make the decision at 0.33 and 0.67\nimport numpy as np\nx = np.random.rand(1,1) # get a random 1x1 matrix using numpy\nx = x[0,0] # pull the entry from the first row and first column\nif x &lt; 0.33:\n    print(x,\" &lt; 1/3\")\nelif x &lt; 0.67:\n    print(\"1/3 &lt;= \",x,\"&lt; 2/3\")\nelse:\n    print(x, \"&gt;= 2/3\")\n(Take note that the output will change every time you run it)\n\n\n\nExercise 1.9 Write code to give the Collatz Sequence \\[\\begin{equation}\nx_{n+1} = \\left\\{ \\begin{array}{ll} x_n / 2, & \\text{$x_n$ is even} \\\\ 3 x_n + 1, & \\text{otherwise} \\end{array} \\right.\n\\end{equation}\\] starting with a positive integer of your choosing. The sequence will converge1 to 1 so your code should stop when the sequence reaches 1.\nHints: To test whether a number x is even you can test whether the remainder after dividing by 2 is zero with (x % 2) == 0. Also you will want to use the integer division // when calculating \\(x_n/2\\).\n\n\n\n\n\n1.3.6 Functions\nMathematicians and programmers talk about functions in very similar ways, but they are not exactly the same. When we say ‚Äúfunction‚Äù in a programming sense we are talking about a chunk of code that you can pass parameters and expect an output of some sort. This is not unlike the mathematician‚Äôs version, but unlike a mathematical function can also have side effects, like plotting a graph for example. So Python‚Äôs definition of a function is a bit more flexible than that of a mathematician.\nIn Python, to define a function we start with def, followed by the function‚Äôs name, any input variables in parenthesis, and a colon. The indented code after the colon is what defines the actions of the function.\n\n\nExample 1.17 The following code defines the polynomial \\(f(x) = x^3 + 3x^2 + 3x + 1\\) and then evaluates the function at a point \\(x=2.3\\).\ndef f(x):\n    return(x**3 + 3*x**2 + 3*x + 1)\nf(2.3)\n\n\nTake careful note of several things in the previous example:\n\nTo define the function we cannot just type it like we would see it one paper. This is not how Python recognizes functions.\nOnce we have the function defined we can call upon it just like we would on paper.\nWe cannot pass symbols into this type of function.2\n\n\n\nExercise 1.10 Define the function \\(g(n) = n^2 + n + 41\\) as a Python function. Write a loop that gives the output for this function for integers from \\(n=0\\) to \\(n=39\\). Euler noticed that each of these outputs is a prime number (check this on your own). Will the function produce a prime for \\(n=40\\)? For \\(n=41\\)?\n\n\n\nExample 1.18 One cool thing that you can do with functions is call them recursively. That is, you can call the same function from within the function itself. This turns out to be really handy in several mathematical situations.\nLet us define a function for the factorial. This function is naturally going to be recursive in the sense that it calls on itself!\ndef Fact(n):\n    if n==0:\n        return(1)\n    else:\n        return( n*Fact(n-1) ) \n        # Note: we are calling the function recursively.\nWhen you run this code there will be no output. You have just defined the function so you can use it later. So let us use it to make a list of the first several factorials. Note the use of a for loop in the following code.\nFactList = [Fact(n) for n in range(0,10)]\nFactList\n\n\n\nExample 1.19 For this next example let us define the sequence \\[\\begin{equation}\nx_{n+1} = \\left\\{ \\begin{array}{ll} 2x_n, & x_n \\in [0,0.5] \\\\ 2x_n - 1, & x_n \\in (0.5,1] \\end{array} \\right.\n\\end{equation}\\] as a function and then build a loop to find the first several iterates of the sequence starting at any real number between 0 and 1.\n# Define the function\ndef MySeq(xn):\n    if xn &lt;= 0.5:\n        return(2*xn)\n    else:\n        return(2*xn-1)\n# Now build a sequence with this function\nx = [0.125] # arbitrary starting point\nfor n in range(0,5): # Let us only build the first 5 terms\n    x.append(MySeq(x[-1]))\nprint(x)\n\n\n\nExample 1.20 A fun way to approximate the square root of two is to start with any positive real number and iterate over the sequence \\[\\begin{equation}\nx_{n+1} = \\frac{1}{2} x_n + \\frac{1}{x_n}\n\\end{equation}\\] until we are within any tolerance we like of the square root of \\(2\\). Write code that defines the sequence as a function and then iterates in a while loop until we are within \\(10^{-8}\\) of the square root of 2.\nWe import the math package so that we get the square root function. More about packages in the next section.\nfrom math import sqrt\ndef f(x):\n    return(0.5*x + 1/x)\nx = 1.1 # arbitrary starting point\nprint(\"approximation \\t\\t exact \\t\\t abs error\")\nwhile abs(x-sqrt(2)) &gt; 10**(-8):\n    x = f(x)\n    print(x, sqrt(2), abs(x - sqrt(2)))\n\n\n\nExercise 1.11 The previous example is a special case of the Babylonian Algorithm for calculating square roots. If you want the square root of \\(S\\) then iterate the sequence \\[\\begin{equation}\nx_{n+1} = \\frac{1}{2} \\left( x_n + \\frac{S}{x_n} \\right)\n\\end{equation}\\] until you are within an appropriate tolerance.\nModify the code given in the previous example to give a list of approximations of the square roots of the natural numbers 2 through 20, each to within \\(10^{-8}\\). This problem will require that you build a function, write a ‚Äòfor‚Äô loop (for the integers 2-20), and write a ‚Äòwhile‚Äô loop inside your ‚Äòfor‚Äô loop to do the iterations.\n\n\n\n\n1.3.7 Lambda Functions\nUsing def to define a function as in the previous subsection is really nice when you have a function that is complicated or requires some bit of code to evaluate. However, in the case of mathematical functions we have a convenient alternative: lambda Functions.\nThe basic idea of a lambda Function is that we just want to state what the variable is and what the rule is for evaluating the function. This is closest to the way that we write mathematical functions. For example, we can define the mathematical function \\(f(x) = x^2+3\\) in two different ways.\n\nUsing def:\n\ndef f(x):\n    return(x**2+3)\n\nUsing lambda:\n\nf = lambda x: x**2+3\nYou can see that in the Lambda Function we are explicitly stating the name of the variable immediately after the word lambda, then we put a colon, and then the function definition.\nNo matter whether we use def or lambda to define the function f, if we want to evaluate the function at a point, say \\(x=1.5\\), then we can write code just like we would mathematically: \\(f(1.5)\\)\nf(1.5) # evaluate the function at x=1.5\nWe can also define Lambda Functions of several variables. For example, if we want to define the mathematical function \\(f(x,y) = x^2 + xy + y^3\\) we could write the code\nf = lambda x, y: x**2 + x*y + y**3\nIf we wanted the value \\(f(2,4)\\) we would now write the code f(2,4).\n\n\nExercise 1.12 Go back to Exercise¬†1.10 and repeat this exercise using a lambda function.\n\n\n\nExercise 1.13 Go back to Exercise¬†1.11 and repeat this exercise using a lambda function.\n\n\n\n\n1.3.8 Packages\nPython was not created as a scientific programming language. The reason Python can be used for scientific computing is that there are powerful extension packages that define additional functions that are needed for scientific calculations.\nLet us start with the math package.\n\n\nExample 1.21 The code below imports the math package into your instance of Python and calculates the cosine of \\(\\pi/4\\).\nimport math\nx = math.cos(math.pi / 4)\nprint(x)\nThe answer, unsurprisingly, is the decimal form of \\(\\sqrt{2}/2\\).\n\n\nYou might already see a potential disadvantage to Python‚Äôs packages: there is now more typing involved! Let us fix this. When you import a package you could just import all of the functions so they can be used by their proper names.\n\n\nExample 1.22 Here we import the entire math package so we can use every one of the functions therein without having to use the math prefix.\nfrom math import * # read this as: from math import everything\nx = cos(pi / 4)\nprint(x)\nThe end result is exactly the same: the decimal form of \\(\\sqrt{2}/2\\), but now we had less typing to do.\n\n\nNow you can freely use the functions that were imported from the math package. There is a disadvantage to this, however. What if we have two packages that import functions with the same name. For example, in the math package and in the numpy package there is a cos() function. In the next block of code we will import both math and numpy, but instead we will import them with shortened names so we can type things a bit faster.\n\n\nExample 1.23 Here we import math and numpy under aliases so we can use the shortened aliases and not mix up which functions belong to which packages.\nimport math as ma\nimport numpy as np\n# use the math version of the cosine function\nx = ma.cos( ma.pi / 4) \n# use the numpy version of the cosine function\ny = np.cos( np.pi / 4) \nprint(x, y)\nBoth x and y in the code give the decimal approximation of \\(\\sqrt{2}/2\\). This is clearly pretty redundant in this really simple case, but you should be able to see where you might want to use this and where you might run into troubles.\n\n\n\nExample 1.24 (Contents of a package) Once you have a package imported you can see what is inside of it using the dir command. The following block of code prints a list of all of the functions inside the math package.\nimport math\nprint(dir(math))\n\n\nBy the way: you only need to import a package once in a session. The only reason we are repeating the import statement in each code block is to make it easier to come back to this material later in a new session, where you will need to import the packages again.\nOf course, there will be times when you need help with a function. You can use the help function to view the help documentation for any function. For example, you can run the code help(math.acos) to get help on the arc cosine function from the math package.\n\n\nExercise 1.14 Import the math package, figure out how the log function works, and write code to calculate the logarithm of the number 8.3 in base 10, base 2, base 16, and base \\(e\\) (the natural logarithm).",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#numerical-python-with-numpy",
    "href": "nmPython.html#numerical-python-with-numpy",
    "title": "1¬† Essential Python",
    "section": "1.4 Numerical Python with NumPy",
    "text": "1.4 Numerical Python with NumPy\nThe base implementation of Python includes the basic programming language, the tools to write loops, check conditions, build and manipulate lists, and all of the other things that we saw in the previous section. In this section we will explore the package numpy that contains optimized numerical routines for doing numerical computations in scientific computing.\n\n\nExample 1.25 To start with, let us look at a really simple example. Say you have a list of real numbers and you want to take the sine of every element in the list. If you just try to take the sine of the list you will get an error. Try it yourself.\nfrom math import pi, sin\nMyList = [0,pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]\nsin(MyList)\nYou could get around this error using some of the tools from base Python, but none of them are very elegant from a programming perspective.\nfrom math import pi, sin\nMyList = [0,pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]\nSineList = [sin(n) for n in MyList]\nSineList\nfrom math import pi, sin\nMyList = [0,pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]\nSineList = [ ]\nfor n in range(0,len(MyList)):\n    SineList.append( sin(MyList[n]) )\nSineList\nPerhaps more simply, say we wanted to square every number in a list. Just appending the code **2 to the end of the list will fail!\nMyList = [1,2,3,4]\nMyList**2 # This will produce an error\nIf, instead, we define the list as a numpy array instead of a Python list then everything will work mathematically exactly the way that we intend.\nimport numpy as np\nMyList = np.array([1,2,3,4])\nMyList**2 # This will work as expected!  \n\n\n\nExercise 1.15 See if you can take the sine of a full list of numbers that are stored in a numpy array.\nHint: you will now see why the numpy package provides its own version of the sine function.\n\n\nThe package numpy is used in many (most) mathematical computations in numerical analysis using Python. It provides algorithms for matrix and vector arithmetic. Furthermore, it is optimized to be able to do these computations in the most efficient possible way (both in terms of memory and in terms of speed).\nTypically when we import numpy we use import numpy as np. This is the standard way to name the numpy package. This means that we will have lots of function with the prefix ‚Äúnp‚Äù in order to call on the numpy functions. Let us first see what is inside the package with the code print(dir(np)) after importing numpy as np. A brief glimpse through the list reveals a huge wealth of mathematical functions that are optimized to work in the best possible way with the Python language. (We are intentionally not showing the output here since it is quite extensive, run it so you can see.)\n\n1.4.1 Numpy Arrays, Array Operations, and Matrix Operations\nIn the previous section you worked with Python lists. As we pointed out, the shortcoming of Python lists is that they do not behave well when we want to apply mathematical functions to the vector as a whole. The ‚Äúnumpy array‚Äù, np.array, is essentially the same as a Python list with the notable exceptions that\n\nIn a numpy array every entry is a floating point number\nIn a numpy array the memory usage is more efficient (mostly since Python is expecting data of all the same type)\nWith a numpy array there are ready-made functions that can act directly on the array as a matrix or a vector\n\nLet us just look at a few examples using numpy. What we are going to do is to define a matrix \\(A\\) and vectors \\(v\\) and \\(w\\) as \\[\\begin{equation}\nA = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}, \\quad v = \\begin{pmatrix} 5\\\\6 \\end{pmatrix} \\quad \\text{and} \\quad w = v^T = \\begin{pmatrix} 5 & 6 \\end{pmatrix}.\n\\end{equation}\\] Then we will do the following\n\nGet the size and shape of these arrays\nGet individual elements, rows, and columns from these arrays\nTreat these arrays as with linear algebra to\n\ndo element-wise multiplication\ndo matrix a vector products\ndo scalar multiplication\ntake the transpose of matrices\ntake the inverse of matrices\n\n\n\n\nExample 1.26 (numpy Matrices) The first thing to note is that a matrix is a list of lists (each row is a list).\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nprint(\"The matrix A is:\\n\",A)\nv = np.array([[5],[6]]) # this creates a column vector\nprint(\"The vector v is:\\n\",v)\nw = np.array([[5,6]]) # this creates a row vector\nprint(\"The vector w is:\\n\",w)\n\n\n\nExample 1.27 (.shape) The .shape attribute can be used to give the shape of a numpy array. Notice that the output is a tuple showing the size (rows, columns).\nprint(\"The shape of the matrix A is \", A.shape)\nprint(\"The shape of the column vector v is \", v.shape)\nprint(\"The shape of the row vector w is \", w.shape)\n\n\n\nExample 1.28 (.size) The .size attribute can be used to give the size of a numpy array. The size of a matrix or vector will be the total number of elements in the array. You can think of this as the product of the values in the tuple coming from the shape method.\nprint(\"The size of the matrix A is \", A.size)\nprint(\"The size of the column vector v is \", v.size)\nprint(\"The size of the row vector w is \", w.size)\n\n\nReading individual elements from a numpy array is the same, essentially, as reading elements from a Python list. We will use square brackets to get the row and column. Remember that the indexing all starts from 0, not 1!\n\nExample 1.29 Let us read the top left and bottom right entries of the matrix \\(A\\).\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nprint(A[0,0]) # top left\nprint(A[1,1]) # bottom right\n\n\n\nExample 1.30 Let us read the first row from that matrix \\(A\\).\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nprint(A[0,:])\n\n\n\nExample 1.31 Let us read the second column from the matrix \\(A\\).\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nprint(A[:,1])\nNotice when we read the column it was displayed as a row. Be careful. Reading a row or a column from a matrix will automatically flatten it into a 1-dimensional array.\n\n\nIf we try to multiply either \\(A\\) and \\(v\\) or \\(A\\) and \\(A\\) we will get some funky results. Unlike in some programming languages like MATLAB, the default notion of multiplication is NOT matrix multiplication. Instead, the default is element-wise multiplication. You may be familiar with this from R.\n\n\nExample 1.32 If we write the code A*A we do NOT do matrix multiplication. Instead we do element-by-element multiplication. This is a common source of issues when dealing with matrices and Linear Algebra in Python.\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nprint(\"Element-wise multiplication:\\n\", A * A)\nprint(\"Matrix multiplication:\\n\", A @ A)\n\n\n\nExample 1.33 If we write A * v Python will do element-wise multiplication across each column since \\(v\\) is a column vector. If we want the matrix A to act on v we write A @ v.\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nv = np.array([[5],[6]])\nprint(\"Element-wise multiplication on each column:\\n\", A * v) \n# A @ v will do proper matrix multiplication\nprint(\"Matrix A acting on vector v:\\n\", A @ v)\n\nIt is up to you to check that these products are indeed correct from the definitions of matrix multiplication from Linear Algebra.\nIt remains to show some of the other basic linear algebra operations: inverses, determinants, the trace, and the transpose.\n\n\nExample 1.34 (Transpose) Taking the transpose of a matrix (swapping the rows and columns) is done with the .T attribute.\nA.T # The transpose is relatively simple\n\n\n\nExample 1.35 (Trace) The trace is done with matrix.trace()\nA.trace() # The trace is pretty darn easy too\nOddly enough, the trace returns a matrix, not a scalar Therefore you will have to read the first entry (index [0,0]) from the answer to just get the trace.\n\n\n\nExample 1.36 (Determinant) The determinant function is hiding under the linalg subpackage inside numpy. Therefore we need to call it as such.\nnp.linalg.det(A)\nYou notice an interesting numerical error here. You can do the determinant easily by hand and so know that it should be exactly \\(-2\\). We‚Äôll discuss the source of these kinds of errors in ?sec-approx.\n\n\n\nExample 1.37 (Inverse) In the linalg subpackage there is also a function for taking the inverse of a matrix.\nAinv = np.linalg.inv(A)\nAinv\nWe can check that we get the identity matrix back:\nA @ Ainv\n\n\n\nExercise 1.16 Now that we can do some basic linear algebra with numpy it is your turn. Define the matrix \\(B\\) and the vector \\(u\\) as\n\n\\[\\begin{equation}\nB = \\begin{pmatrix} 1 & 4 & 8 \\\\ 2 & 3 & -1 \\\\ 0 & 9 & -3 \\end{pmatrix} \\quad \\text{and} \\quad u = \\begin{pmatrix} 6 \\\\ 3 \\\\ -7 \\end{pmatrix}.\n\\end{equation}\\]\nThen find\n\n\\(Bu\\)\n\\(B^2\\) (in the traditional linear algebra sense)\nThe size and shape of \\(B\\)\n\\(B^T u\\)\nThe element-by-element product of \\(B\\) with itself\nThe dot product of \\(u\\) with the first row of \\(B\\)\n\n\n\n\n\n1.4.2 arange, linspace, zeros, ones, and meshgrid\nThere are a few built-in ways to build arrays in numpy that save a bit of time in many scientific computing settings.\n\n\nExample 1.38 The np.arange (array range) function is great for building sequences.\nimport numpy as np\nx = np.arange(0,0.6,0.1)\nx\nnp.arange builds an array of floating point numbers with the arguments start, stop, and step. Note that the stop value itself is not included in the result.\n\n\n\nExample 1.39 The np.linspace function builds an array of floating point numbers starting at one point, ending at the next point, and have exactly the number of points specified with equal spacing in between: start, stop, number of points.\nimport numpy as np\ny = np.linspace(0,5,11)\ny\nIn a linear space you are always guaranteed to hit the stop point exactly, but you do not have direct control over the step size.\n\n\n\nExample 1.40 The np.zeros function builds an array of zeros. This is handy for pre-allocating memory.\nimport numpy as np\nz = np.zeros((3,5)) # create a 3x5 matrix of zeros\nz\n\n\n\nExample 1.41 The np.ones function builds an array of ones.\nimport numpy as np\nu = np.ones((3,5)) # create a 3x5 matrix of ones\nu\n\n\n\nExample 1.42 The np.meshgrid function builds two arrays that when paired make up the ordered pairs for a 2D (or higher D) mesh grid of points. This is handy for building 2D (or higher dimensional) arrays of data for multi-variable functions. Notice that the output is defined as a tuple.\nimport numpy as np\nx, y = np.meshgrid( np.linspace(0,5,6) , np.linspace(0,5,6) )\nprint(\"x = \", x)\nprint(\"y = \", y)\nThe thing to notice with the np.meshgrid() function is that when you lay the two arrays on top of each other, the matching entries give every ordered pair in the domain.\nIf the purpose of this is not clear to you yet, don‚Äôt worry. You will see it used a lot later in the module.\n\n\n\nExercise 1.17 Now it is time to practice with some of these numpy functions.\n\nCreate a numpy array of the numbers 1 through 10 and square every entry in the list without using a loop.\nCreate a \\(10 \\times 10\\) identity matrix and change the top right corner to a 5. Hint: np.identity()\nFind the matrix-vector product of the answer to part (b) and the answer to part (a).\nChange the bottom row of your matrix from part (b) to all \\(3\\)‚Äôs, then change the third column to all \\(7\\)‚Äôs, and then find the \\(5^{th}\\) power of this matrix.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#plotting-with-matplotlib",
    "href": "nmPython.html#plotting-with-matplotlib",
    "title": "1¬† Essential Python",
    "section": "1.5 Plotting with Matplotlib",
    "text": "1.5 Plotting with Matplotlib\nA key part of scientific computing is plotting your results or your data. The tool in Python best-suited to this task is the package matplotlib. As with all of the other packages in Python, it is best to learn just the basics first and then to dig deeper later. One advantage to using matplotlib in Python is that it is modelled off of MATLAB‚Äôs plotting tools. People coming from a MATLAB background should feel pretty comfortable here, but there are some differences to be aware of.\n\n1.5.1 Basics with plt.plot()\nWe are going to start right away with an example. In this example, however, we will walk through each of the code chunks one-by-one so that we understand how to set up a proper plot.\nBelow we will mention some tricks for getting the plots to render that only apply to Jupyter Notebooks. If you are using Google Colab then you may not need some of these little tricks.\n\n\nExample 1.43 (Plotting with matplotlib) In the first example we want to simply plot the sine function on the domain \\(x \\in [0,2\\pi]\\), colour it green, put a grid on it, and give a meaningful legend and axis labels. To do so we first need to take care of a couple of housekeeping items.\n\nImport numpy so we can take advantage of some good numerical routines.\nImport matplotlib‚Äôs pyplot module. The standard way to pull it in is with the nickname plt (just like with numpy when we import it as np).\n\n\nimport numpy as np \nimport matplotlib.pyplot as plt\n\nIn Jupyter Notebooks the plots will not show up unless you tell the notebook to put them ‚Äúinline.‚Äù Usually we will use the following command to get the plots to show up. You do not need to do this in Google Colab. The percent sign is called a magic command in Jupyter Notebooks. This is not a Python command, but it is a command for controlling the Jupyter IDE specifically.\n%matplotlib inline\nNow we will build a numpy array of \\(x\\) values (using the np.linspace function) and a numpy array of \\(y\\) values from the sine function.\n\n# 100 equally spaced points from 0 to 2pi\nx = np.linspace(0,2*np.pi, 100) \ny = np.sin(x)\n\n\nNext, build the plot with plt.plot(). The syntax is: plt.plot(x, y, ‚Äôcolor‚Äô, ...)¬†where you have several options that you can pass (more on that later).\nWe send the plot label directly to the plot function. This is optional and we could set the legend up separately if we like.\nThen we will add the grid with plt.grid()\nThen we will add the legend to the plot\nFinally we will add the axis labels\nWe end the plotting code with plt.show() to tell Python to finally show the plot. This line of code tells Python that you are done building that plot.\n\n\nplt.plot(x,y, 'green', label='The Sine Function')\nplt.grid()\nplt.legend()\nplt.xlabel(\"x axis\")\nplt.ylabel(\"y axis\")\nplt.show()\n\n\n\n\n\n\n\nFigure¬†1.1: The sine function\n\n\n\n\n\n\n\n\nExample 1.44 Now let us do a second example, but this time we want to show four different plots on top of each other. When you start a figure, matplotlib is expecting all of those plots to be layered on top of each other. (Note:For MATLAB users, this means that you do not need the hold on command since it is automatically ‚Äúon.‚Äù)\nIn this example we will plot \\[\\begin{equation}\ny_0 = \\sin(2\\pi x) \\quad y_1 = \\cos(2 \\pi x) \\quad y_2 = y_0 + y_1 \\quad \\text{and} \\quad y_3 = y_0 - y_1\n\\end{equation}\\] on the domain \\(x \\in [0,1]\\) with 100 equally spaced points. we will give each of the plots a different line style, built a legend, put a grid on the plot, and give axis labels.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# %matplotlib inline # you may need this in Jupyter Notebooks\n\n# build the x and y values\nx = np.linspace(0,1,100)\ny0 = np.sin(2*np.pi*x)\ny1 = np.cos(2*np.pi*x)\ny2 = y0 + y1\ny3 = y0 - y1\n\n# plot each of the functions \n# (notice that they will be on the same axes)\nplt.plot(x, y0, 'b-.', label=r\"$y_0 = \\sin(2\\pi x)$\")\nplt.plot(x, y1, 'r--', label=r\"$y_1 = \\cos(2\\pi x)$\")\nplt.plot(x, y2, 'g:', label=r\"$y_2 = y_0 + y_1$\")\nplt.plot(x, y3, 'k-', label=r\"$y_3 = y_0 - y_1$\")\n\n# put in a grid, legend, title, and axis labels\nplt.grid()\nplt.legend()\nplt.title(\"Awesome Graph\")\nplt.xlabel('x axis label')\nplt.ylabel('y axis label')\nplt.show()\n\n\n\n\n\n\n\nFigure¬†1.2: Plots of the sine, cosine, and sums and differences.\n\n\n\n\n\nNotice the r in front of the strings defining the legend. This prevents the backslash that is used a lot in LaTeX to be interpreted as an escape character. These strings are referred to as raw strings.\nThe legend was placed automatically at the lower left of the plot. There are ways to control the placement of the legend if you wish, but for now just let Python and matplotlib have control over the placement.\n\n\n\nExample 1.45 Now let us create the same plot with slightly different code. The plot function can take several \\((x, y)\\) pairs in the same line of code. This can really shrink the amount of coding that you have to do when plotting several functions on top of each other.\n\n# The next line of code does all of the plotting of all \n# of the functions.  Notice the order: x, y, color and \n# line style, repeat\nimport numpy as np\nimport matplotlib.pyplot as plt\nx = np.linspace(0,1,100)\ny0 = np.sin(2*np.pi*x)\ny1 = np.cos(2*np.pi*x)\ny2 = y0 + y1\ny3 = y0 - y1\nplt.plot(x, y0, 'b-.', x, y1, 'r--', x, y2, 'g:', x, y3, 'k-')\n\nplt.grid()\nplt.legend([r\"$y_0 = \\sin(2\\pi x)$\",r\"$y_1 = \\cos(2\\pi x)$\",\\\n            r\"$y_2 = y_0 + y_1$\",r\"$y_3 = y_0 - y_1$\"])\nplt.title(\"Awesome Graph\")\nplt.xlabel('x axis label')\nplt.ylabel('y axis label')\nplt.show()\n\n\n\n\n\n\n\nFigure¬†1.3: A second plot of the sine, cosine, and sums and differences.\n\n\n\n\n\n\n\n\nExercise 1.18 Plot the functions \\(f(x) = x^2\\), \\(g(x) = x^3\\), and \\(h(x) = x^4\\) on the same axes. Use the domain \\(x \\in [0,1]\\). Put a grid, a legend, a title, and appropriate labels on the axes.\n\n\n\n\n1.5.2 Subplots\nIt is often very handy to place plots side-by-side or as some array of plots. The subplots command allows us that control. The main idea is that we are setting up a matrix of blank plots and then populating the axes with the plots that we want.\n\n\nExample 1.46 Let us repeat the previous exercise, but this time we will put each of the plots in its own subplot. There are a few extra coding quirks that come along with building subplots so we will highlight each block of code separately.\n\nFirst we set up the plot area with plt.subplots(). The first two inputs to the subplots command are the number of rows and the number of columns in your plot array. For the first example we will do 2 rows of plots with 2 columns ‚Äì so there are four plots total.\nThen we build each plot individually telling matplotlib which axes to use for each of the things in the plots.\nNotice the small differences in how we set the titles and labels\nIn this example we are setting the \\(y\\)-axis to the interval \\([-2,2]\\) for consistency across all of the plots.\n\n\n# set up the blank matrix of plots\nimport numpy as np\nimport matplotlib.pyplot as plt\nx = np.linspace(0,1,100)\ny0 = np.sin(2*np.pi*x)\ny1 = np.cos(2*np.pi*x)\ny2 = y0 + y1\ny3 = y0 - y1\n\nfig, axes = plt.subplots(nrows = 2, ncols = 2)\n\n# Build the first plot\naxes[0,0].plot(x, y0, 'b-.')\naxes[0,0].grid()\naxes[0,0].set_title(r\"$y_0 = \\sin(2\\pi x)$\")\naxes[0,0].set_ylim(-2,2)\naxes[0,0].set_xlabel(\"x\")\naxes[0,0].set_ylabel(\"y\")\n\n# Build the second plot\naxes[0,1].plot(x, y1, 'r--')\naxes[0,1].grid()\naxes[0,1].set_title(r\"$y_1 = \\cos(2\\pi x)$\")\naxes[0,1].set_ylim(-2,2)\naxes[0,1].set_xlabel(\"x\")\naxes[0,1].set_ylabel(\"y\")\n\n# Build the first plot\naxes[1,0].plot(x, y2, 'g:')\naxes[1,0].grid()\naxes[1,0].set_title(r\"$y_2 = y_0 + y_1$\")\naxes[1,0].set_ylim(-2,2)\naxes[1,0].set_xlabel(\"x\")\naxes[1,0].set_ylabel(\"y\")\n\n# Build the first plot\naxes[1,1].plot(x, y3, 'k-')\naxes[1,1].grid()\naxes[1,1].set_title(r\"$y_3 = y_0 - y_1$\")\naxes[1,1].set_ylim(-2,2)\naxes[1,1].set_xlabel(\"x\")\naxes[1,1].set_ylabel(\"y\")\n\nfig.tight_layout()\nplt.show()\n\n\n\n\n\n\n\nFigure¬†1.4: An example of subplots\n\n\n\n\n\nThe fig.tight_layout() command makes the plot labels a bit more readable in this instance (again, something you can play with).\n\n\n\nExercise 1.19 Put the functions \\(f(x) = x^2\\), \\(g(x) = x^3\\) and \\(h(x) = x^4\\) in a subplot environment with 1 row and 3 columns of plots. Use the unit interval as the domain and range for all three plot. Make sure that each plot has a grid, appropriate labels, an appropriate title, and the overall figure has a title.\n\n1.5.3 Logarithmic Scaling with semilogy, semilogx, and loglog\nIt is occasionally useful to scale an axis logarithmically. This arises most often when we are examining an exponential function, or some other function, that is close to zero for much of the domain. Scaling logarithmically allows us to see how small the function is getting in orders of magnitude instead of as a raw real number. we will use this often in numerical methods.\n\n\n\n\nExample 1.47 In this example we will plot the function \\(y = 10^{-0.01x}\\) on a regular (linear) scale and on a logarithmic scale on the \\(y\\) axis. We use the interval \\([0,500]\\) on the \\(x\\) axis.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nx = np.linspace(0,500,1000)\ny = 10**(-0.01*x)\nfig, axis = plt.subplots(1,2)\n\naxis[0].plot(x,y, 'r')\naxis[0].grid()\naxis[0].set_title(\"Linearly scaled y axis\")\naxis[0].set_xlabel(\"x\")\naxis[0].set_ylabel(\"y\")\n\naxis[1].semilogy(x,y, 'r')\naxis[1].grid()\naxis[1].set_title(\"Logarithmically scaled y axis\")\naxis[1].set_xlabel(\"x\")\naxis[1].set_ylabel(\"Log(y)\")\n\nfig.tight_layout()\nplt.show()\n\n\n\n\n\n\n\nFigure¬†1.5: An example of using logarithmic scaling.\n\n\n\n\n\nIt should be noted that the same result can be achieved using the yscale command along with the plot command instead of using the semilogy command. So you could replace\naxis[1].semilogy(x,y, 'r')\nby\naxis[1].plot(x,y, 'r')\naxis[1].set_yscale(\"log\")\nto produce identical results.\n\n\n\nExercise 1.20 Plot the function \\(f(x) = x^3\\) for \\(x \\in [0,1]\\) on linearly scaled axes, logarithmic axis in the \\(y\\) direction, logarithmically scaled axes in the \\(x\\) direction, and a log-log plot with logarithmic scaling on both axes. Use subplots to put your plots side-by-side. Give appropriate labels, titles, etc.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#sec-pandas",
    "href": "nmPython.html#sec-pandas",
    "title": "1¬† Essential Python",
    "section": "1.6 Dataframes with Pandas",
    "text": "1.6 Dataframes with Pandas\nThe Pandas package provides Python with the ability to work with tables of data similar to what R provides via its dataframes. As we will not work with data in this module, we do not need to dive deep into the Pandas package. We will only use it to collect computational results into tables for easier display.\n\nExample 1.48 In this example we will build a simple dataframe with Pandas. We will build a table of the first 10 natural numbers and their squares and cubes. We will then display the table.\n\nimport numpy as np\nimport pandas as pd\n\n# Calculate the columns for the table\nn = np.arange(1,11)\nn2 = n**2\nn3 = n**3\n\n# Combine the columns into a data frame with headers\ndf = pd.DataFrame({'n': n, 'n^2': n2, 'n^3': n3})\ndf\n\n\n\n\n\n\n\n\nn\nn^2\nn^3\n\n\n\n\n0\n1\n1\n1\n\n\n1\n2\n4\n8\n\n\n2\n3\n9\n27\n\n\n3\n4\n16\n64\n\n\n4\n5\n25\n125\n\n\n5\n6\n36\n216\n\n\n6\n7\n49\n343\n\n\n7\n8\n64\n512\n\n\n8\n9\n81\n729\n\n\n9\n10\n100\n1000",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#sec-python_exercises",
    "href": "nmPython.html#sec-python_exercises",
    "title": "1¬† Essential Python",
    "section": "1.7 Problems",
    "text": "1.7 Problems\nThese problem exercises here are meant for you to practice and improve your coding skills. Please refrain from relying too much on Gemini or any other AI for solving these exercises. The point is to struggle through the code, get it wrong many times, debug, and then to eventually have working code. So I recommend switching off the AI features in Google Colab for the purpose of these exercises.\n\n\nExercise 1.21 (This problem is modified from (‚ÄúProject Euler‚Äù n.d.))\nIf we list all of the numbers below 10 that are multiples of 3 or 5 we get 3, 5, 6, and 9. The sum of these multiples is 23. Write code to find the sum of all the multiples of 3 or 5 below 1000. Your code needs to run error free and output only the sum. There are of course many ways you could approach this exercise. Compare your approach to that of others in your group.\n\n\n\nExercise 1.22 (This problem is modified from (‚ÄúProject Euler‚Äù n.d.))\nEach new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: \\[\\begin{equation}\n1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \\dots\n\\end{equation}\\] By considering the terms in the Fibonacci sequence whose values do not exceed four million, write code to find the sum of the even-valued terms. Your code needs to run error free and output only the sum.\n\n\n\nExercise 1.23 Write computer code that will draw random numbers from the unit interval \\([0,1]\\), distributed uniformly (using Python‚Äôs np.random.rand()), until the sum of the numbers that you draw is greater than 1. Keep track of how many numbers you draw. Then write a loop that does this process many many times. On average, how many numbers do you have to draw until your sum is larger than 1?\n\nHint #1:\n\nUse the np.random.rand()command to draw a single number from a uniform distribution with bounds \\((0,1)\\).\n\nHint #2:\n\nYou should do this more than 1,000,000 times to get a good average ‚Ä¶ and the number that you get should be familiar!\n\n\n\n\n\nExercise 1.24 (This problem is modified from (‚ÄúProject Euler‚Äù n.d.))\nThe sum of the squares of the first ten natural numbers is, \\[\\begin{equation}\n1^2 + 2^2 + \\dots + 10^2 = 385\n\\end{equation}\\] The square of the sum of the first ten natural numbers is, \\[\\begin{equation}\n(1 + 2 + \\dots + 10)^2 = 55^2 = 3025\n\\end{equation}\\] Hence the difference between the square of the sum of the first ten natural numbers and the sum of the squares is \\(3025 - 385 = 2640\\).\nWrite code to find the difference between the square of the sum of the first one hundred natural numbers and the sum of the squares. Your code needs to run error free and output only the difference.\n\n\n\nExercise 1.25 (This problem is modified from (‚ÄúProject Euler‚Äù n.d.))\nThe prime factors of \\(13195\\) are \\(5, 7, 13\\) and \\(29\\). Write code to find the largest prime factor of the number \\(600851475143\\)? Your code needs to run error free and output only the largest prime factor.\n\n\n\nExercise 1.26 (This problem is modified from (‚ÄúProject Euler‚Äù n.d.))\nThe number 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. Write code to find the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?\nHint: You will likely want to use modular division for this problem.\n\n\n\nExercise 1.27 The following iterative sequence is defined for the set of positive integers: \\[\\begin{equation}\n\\begin{aligned} & n \\to \\frac{n}{2} \\quad (n \\text{ is even}) \\\\ & n \\to 3n + 1 \\quad (n \\text{ is odd}) \\end{aligned}\n\\end{equation}\\] Using the rule above and starting with \\(13\\), we generate the following sequence: \\[\\begin{equation}\n13 \\to 40 \\to 20 \\to 10 \\to 5 \\to 16 \\to 8 \\to 4 \\to 2 \\to 1\n\\end{equation}\\] It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1. This has been verified on computers for massively large starting numbers, but this does not constitute a proof that it will work this way for all starting numbers.\nWrite code to determine which starting number, under one million, produces the longest chain. NOTE: Once the chain starts, the terms are allowed to go above one million.\n\nFootnotes\n\n\n\n\n‚ÄúProject Euler.‚Äù n.d. Accessed December 14, 2023. https://projecteuler.net/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#footnotes",
    "href": "nmPython.html#footnotes",
    "title": "1¬† Essential Python",
    "section": "",
    "text": "Actually, it is still an open mathematical question whether every integer seed will converge to 1. The Collatz sequence has been checked for many millions of initial seeds and they all converge to 1, but there is no mathematical proof that it will always happen. You will check the conjecture numerically in Exercise¬†1.27‚Ü©Ô∏é\nThere is the sympy package if you want to do symbolic computations, but we will not use that in this module.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Acton, Forman S. 1990. Numerical Methods That\nWork. 1St Edition edition. Washington, D.C: The\nMathematical Association of America.\n\n\nBurden, Richard L., and J. Douglas Faires. 2010. Numerical\nAnalysis. 9th ed. Brooks Cole.\n\n\nButcher, J. C. 2016. Numerical Methods for Ordinary Differential\nEquations. Third edition. Wiley. https://yorsearch.york.ac.uk/permalink/f/1kq3a7l/44YORK_ALMA_DS51336126850001381.\n\n\nKincaid, D. R., and E. W. Cheney. 2009. Numerical\nAnalysis: Mathematics of\nScientific Computing. Pure and Applied\nUndergraduate Texts. American Mathematical Society.\n\n\nPress, William H., Saul A. Teukolsky, William T. Vetterling, and Brian\nP. Flannery. 2007. Numerical Recipes: The Art of Scientific\nComputing. Cambridge University Press. https://numerical.recipes/.\n\n\n‚ÄúProject Euler.‚Äù n.d. Accessed December 14, 2023. https://projecteuler.net/.",
    "crumbs": [
      "References"
    ]
  }
]